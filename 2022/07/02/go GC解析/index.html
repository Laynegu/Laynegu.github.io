<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"laynegu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="以下文章来源于Golang源码探索(三) GC的实现原理 Golang从1.5开始引入了三色GC, 经过多次改进, 当前的1.9版本的GC停顿时间已经可以做到极短.停顿时间的减少意味着”最大响应时间”的缩短, 这也让go更适合编写网络服务程序.这篇文章将通过分析golang的源代码来讲解go中的三色GC的实现原理.">
<meta property="og:type" content="article">
<meta property="og:title" content="go GC解析">
<meta property="og:url" content="https://laynegu.github.io/2022/07/02/go%20GC%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="layne&#39;s Blog">
<meta property="og:description" content="以下文章来源于Golang源码探索(三) GC的实现原理 Golang从1.5开始引入了三色GC, 经过多次改进, 当前的1.9版本的GC停顿时间已经可以做到极短.停顿时间的减少意味着”最大响应时间”的缩短, 这也让go更适合编写网络服务程序.这篇文章将通过分析golang的源代码来讲解go中的三色GC的实现原理.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165637665-171579804.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165646055-1225522876.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165652071-1143420937.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165701665-214853306.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165711883-1079047912.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165724540-2110504561.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165733821-1250658446.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165741149-1015705312.png">
<meta property="og:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165749274-1840348396.png">
<meta property="article:published_time" content="2022-07-02T14:58:02.000Z">
<meta property="article:modified_time" content="2022-07-02T15:05:34.577Z">
<meta property="article:author" content="layne">
<meta property="article:tag" content="go">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="垃圾回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165637665-171579804.png">

<link rel="canonical" href="https://laynegu.github.io/2022/07/02/go%20GC%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>go GC解析 | layne's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">layne's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://laynegu.github.io/2022/07/02/go%20GC%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="layne">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="layne's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go GC解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-02 22:58:02 / 修改时间：23:05:34" itemprop="dateCreated datePublished" datetime="2022-07-02T22:58:02+08:00">2022-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>以下文章来源于<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zkweb/p/7880099.html">Golang源码探索(三) GC的实现原理</a></p>
<p>Golang从1.5开始引入了三色GC, 经过多次改进, 当前的1.9版本的GC停顿时间已经可以做到极短.<br>停顿时间的减少意味着”最大响应时间”的缩短, 这也让go更适合编写网络服务程序.<br>这篇文章将通过分析golang的源代码来讲解go中的三色GC的实现原理.</p>
<p>这个系列分析的golang源代码是Google官方的实现的1.9.2版本, 不适用于其他版本和gccgo等其他实现,<br>运行环境是Ubuntu 16.04 LTS 64bit.<br>首先会讲解基础概念, 然后讲解分配器, 再讲解收集器的实现.</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>go在程序启动时会分配一块虚拟内存地址是连续的内存, 结构如下:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165637665-171579804.png" alt="img"></p>
<p>这一块内存分为了3个区域, 在X64上大小分别是512M, 16G和512G, 它们的作用如下:</p>
<p><strong>arena</strong></p>
<p>arena区域就是我们通常说的<strong>heap</strong>, go从heap分配的内存都在这个区域中.</p>
<p><strong>bitmap</strong></p>
<p>bitmap区域用于表示arena区域中哪些地址保存了对象, 并且对象中哪些地址包含了<strong>指针</strong>.<br>bitmap区域中一个byte(8 bit)对应了arena区域中的四个指针大小的内存, 也就是2 bit对应一个指针大小的内存.<br>所以bitmap区域的大小是 512GB &#x2F; 指针大小(8 byte) &#x2F; 4 &#x3D; 16GB.</p>
<p>bitmap区域中的一个byte对应arena区域的四个指针大小的内存的结构如下,<br>每一个指针大小的内存都会有两个bit分别表示是否应该继续扫描和是否包含指针:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165646055-1225522876.png" alt="img"></p>
<p>bitmap中的byte和arena的对应关系从末尾开始, 也就是随着内存分配会向两边扩展:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165652071-1143420937.png" alt="img"></p>
<p><strong>spans</strong></p>
<p>spans区域用于表示arena区中的某一页(Page)属于哪个span, 什么是span将在下面介绍.<br>spans区域中一个指针(8 byte)对应了arena区域中的一页(在go中一页&#x3D;8KB).<br>所以spans的大小是 512GB &#x2F; 页大小(8KB) * 指针大小(8 byte) &#x3D; 512MB.</p>
<p>spans区域的一个指针对应arena区域的一页的结构如下, 和bitmap不一样的是对应关系会从开头开始:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165701665-214853306.png" alt="img"></p>
<h3 id="什么时候从Heap分配对象"><a href="#什么时候从Heap分配对象" class="headerlink" title="什么时候从Heap分配对象"></a>什么时候从Heap分配对象</h3><p>很多讲解go的文章和书籍中都提到过, go会自动确定哪些对象应该放在栈上, 哪些对象应该放在堆上.<br>简单的来说, 当一个对象的内容可能在生成该对象的函数结束后被访问, 那么这个对象就会分配在堆上.<br>在堆上分配对象的情况包括:</p>
<ul>
<li>返回对象的指针</li>
<li>传递了对象的指针到其他函数</li>
<li>在闭包中使用了对象并且需要修改对象</li>
<li>使用new</li>
</ul>
<p>在C语言中函数返回在栈上的对象的指针是非常危险的事情, 但在go中却是安全的, 因为这个对象会自动在堆上分配.<br>go决定是否使用堆分配对象的过程也叫”逃逸分析”.</p>
<h3 id="GC-Bitmap"><a href="#GC-Bitmap" class="headerlink" title="GC Bitmap"></a>GC Bitmap</h3><p>GC在标记时需要知道哪些地方包含了指针, 例如上面提到的bitmap区域涵盖了arena区域中的指针信息.<br>除此之外, GC还需要知道栈空间上哪些地方包含了指针,<br>因为栈空间不属于arena区域, 栈空间的指针信息将会在<strong>函数信息</strong>里面.<br>另外, GC在分配对象时也需要根据对象的类型设置bitmap区域, 来源的指针信息将会在<strong>类型信息</strong>里面.</p>
<p>总结起来go中有以下的GC Bitmap:</p>
<ul>
<li>bitmap区域: 涵盖了arena区域, 使用2 bit表示一个指针大小的内存</li>
<li>函数信息: 涵盖了函数的栈空间, 使用1 bit表示一个指针大小的内存 (位于stackmap.bytedata)</li>
<li>类型信息: 在分配对象时会复制到bitmap区域, 使用1 bit表示一个指针大小的内存 (位于_type.gcdata)</li>
</ul>
<h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3><p>span是用于分配对象的区块, 下图是简单说明了Span的内部结构:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165711883-1079047912.png" alt="img"></p>
<p>通常一个span包含了多个大小相同的元素, 一个元素会保存一个对象, 除非:</p>
<ul>
<li>span用于保存大对象, 这种情况span只有一个元素</li>
<li>span用于保存极小对象且不包含指针的对象(tiny object), 这种情况span会用一个元素保存多个对象</li>
</ul>
<p>span中有一个freeindex标记下一次分配对象时应该开始搜索的地址, 分配后freeindex会增加,<br>在freeindex之前的元素都是已分配的, 在freeindex之后的元素有可能已分配, 也有可能未分配.</p>
<p>span每次GC以后都可能会回收掉一些元素, allocBits用于标记哪些元素是已分配的, 哪些元素是未分配的.<br>使用freeindex + allocBits可以在分配时跳过已分配的元素, 把对象设置在未分配的元素中,<br>但因为每次都去访问allocBits效率会比较慢, span中有一个整数型的allocCache用于缓存freeindex开始的bitmap, 缓存的bit值与原值相反.</p>
<p>gcmarkBits用于在gc时标记哪些对象存活, <strong>每次gc以后gcmarkBits会变为allocBits</strong>.<br>需要注意的是span结构本身的内存是从系统分配的, 上面提到的spans区域和bitmap区域都只是一个索引.</p>
<h3 id="Span的类型"><a href="#Span的类型" class="headerlink" title="Span的类型"></a>Span的类型</h3><p>span根据大小可以分为67个类型, 如下:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// class  bytes/obj  bytes/span  objects  tail waste  max waste</span><br><span class="line">//     1          8        8192     1024           0     87.50%</span><br><span class="line">//     2         16        8192      512           0     43.75%</span><br><span class="line">//     3         32        8192      256           0     46.88%</span><br><span class="line">//     4         48        8192      170          32     31.52%</span><br><span class="line">//     5         64        8192      128           0     23.44%</span><br><span class="line">//     6         80        8192      102          32     19.07%</span><br><span class="line">//     7         96        8192       85          32     15.95%</span><br><span class="line">//     8        112        8192       73          16     13.56%</span><br><span class="line">//     9        128        8192       64           0     11.72%</span><br><span class="line">//    10        144        8192       56         128     11.82%</span><br><span class="line">//    11        160        8192       51          32      9.73%</span><br><span class="line">//    12        176        8192       46          96      9.59%</span><br><span class="line">//    13        192        8192       42         128      9.25%</span><br><span class="line">//    14        208        8192       39          80      8.12%</span><br><span class="line">//    15        224        8192       36         128      8.15%</span><br><span class="line">//    16        240        8192       34          32      6.62%</span><br><span class="line">//    17        256        8192       32           0      5.86%</span><br><span class="line">//    18        288        8192       28         128     12.16%</span><br><span class="line">//    19        320        8192       25         192     11.80%</span><br><span class="line">//    20        352        8192       23          96      9.88%</span><br><span class="line">//    21        384        8192       21         128      9.51%</span><br><span class="line">//    22        416        8192       19         288     10.71%</span><br><span class="line">//    23        448        8192       18         128      8.37%</span><br><span class="line">//    24        480        8192       17          32      6.82%</span><br><span class="line">//    25        512        8192       16           0      6.05%</span><br><span class="line">//    26        576        8192       14         128     12.33%</span><br><span class="line">//    27        640        8192       12         512     15.48%</span><br><span class="line">//    28        704        8192       11         448     13.93%</span><br><span class="line">//    29        768        8192       10         512     13.94%</span><br><span class="line">//    30        896        8192        9         128     15.52%</span><br><span class="line">//    31       1024        8192        8           0     12.40%</span><br><span class="line">//    32       1152        8192        7         128     12.41%</span><br><span class="line">//    33       1280        8192        6         512     15.55%</span><br><span class="line">//    34       1408       16384       11         896     14.00%</span><br><span class="line">//    35       1536        8192        5         512     14.00%</span><br><span class="line">//    36       1792       16384        9         256     15.57%</span><br><span class="line">//    37       2048        8192        4           0     12.45%</span><br><span class="line">//    38       2304       16384        7         256     12.46%</span><br><span class="line">//    39       2688        8192        3         128     15.59%</span><br><span class="line">//    40       3072       24576        8           0     12.47%</span><br><span class="line">//    41       3200       16384        5         384      6.22%</span><br><span class="line">//    42       3456       24576        7         384      8.83%</span><br><span class="line">//    43       4096        8192        2           0     15.60%</span><br><span class="line">//    44       4864       24576        5         256     16.65%</span><br><span class="line">//    45       5376       16384        3         256     10.92%</span><br><span class="line">//    46       6144       24576        4           0     12.48%</span><br><span class="line">//    47       6528       32768        5         128      6.23%</span><br><span class="line">//    48       6784       40960        6         256      4.36%</span><br><span class="line">//    49       6912       49152        7         768      3.37%</span><br><span class="line">//    50       8192        8192        1           0     15.61%</span><br><span class="line">//    51       9472       57344        6         512     14.28%</span><br><span class="line">//    52       9728       49152        5         512      3.64%</span><br><span class="line">//    53      10240       40960        4           0      4.99%</span><br><span class="line">//    54      10880       32768        3         128      6.24%</span><br><span class="line">//    55      12288       24576        2           0     11.45%</span><br><span class="line">//    56      13568       40960        3         256      9.99%</span><br><span class="line">//    57      14336       57344        4           0      5.35%</span><br><span class="line">//    58      16384       16384        1           0     12.49%</span><br><span class="line">//    59      18432       73728        4           0     11.11%</span><br><span class="line">//    60      19072       57344        3         128      3.57%</span><br><span class="line">//    61      20480       40960        2           0      6.87%</span><br><span class="line">//    62      21760       65536        3         256      6.25%</span><br><span class="line">//    63      24576       24576        1           0     11.45%</span><br><span class="line">//    64      27264       81920        3         128     10.00%</span><br><span class="line">//    65      28672       57344        2           0      4.91%</span><br><span class="line">//    66      32768       32768        1           0     12.50%</span><br></pre></td></tr></table></figure>

<p>以类型(class)为1的span为例,<br>span中的元素大小是8 byte, span本身占1页也就是8K, 一共可以保存1024个对象.</p>
<p>在分配对象时, 会根据对象的大小决定使用什么类型的span,<br>例如16 byte的对象会使用span 2, 17 byte的对象会使用span 3, 32 byte的对象会使用span 3.<br>从这个例子也可以看到, 分配17和32 byte的对象都会使用span 3, 也就是说部分大小的对象在分配时会浪费一定的空间.</p>
<p>有人可能会注意到, 上面最大的span的元素大小是32K, 那么分配超过32K的对象会在哪里分配呢?<br>超过32K的对象称为”大对象”, 分配大对象时, 会直接从heap分配一个特殊的span,<br>这个特殊的span的类型(class)是0, 只包含了一个大对象, span的大小由对象的大小决定.</p>
<p>特殊的span加上的66个标准的span, 一共组成了67个span类型.</p>
<h3 id="Span的位置"><a href="#Span的位置" class="headerlink" title="Span的位置"></a>Span的位置</h3><p>在<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zkweb/p/7815600.html">前一篇</a>中我提到了P是一个虚拟的资源, 同一时间只能有一个线程访问同一个P, 所以P中的数据不需要锁.<br>为了分配对象时有更好的性能, 各个P中都有span的缓存(也叫mcache), 缓存的结构如下:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165724540-2110504561.png" alt="img"></p>
<p>各个P中按span类型的不同, 有67*2&#x3D;134个span的缓存,</p>
<p>其中scan和noscan的区别在于,<br>如果对象包含了指针, 分配对象时会使用scan的span,<br>如果对象不包含指针, 分配对象时会使用noscan的span.<br>把span分为scan和noscan的意义在于,<br>GC扫描对象的时候对于noscan的span可以不去查看bitmap区域来标记子对象, 这样可以大幅提升标记的效率.</p>
<p>在分配对象时将会从以下的位置获取适合的span用于分配:</p>
<ul>
<li>首先从P的缓存(mcache)获取, 如果有缓存的span并且未满则使用, 这个步骤不需要锁</li>
<li>然后从全局缓存(mcentral)获取, 如果获取成功则设置到P, 这个步骤需要锁</li>
<li>最后从mheap获取, 获取后设置到全局缓存, 这个步骤需要锁</li>
</ul>
<p>在P中缓存span的做法跟CoreCLR中线程缓存分配上下文(Allocation Context)的做法相似,<br>都可以让分配对象时大部分时候不需要线程锁, 改进分配的性能.</p>
<h1 id="分配对象的处理"><a href="#分配对象的处理" class="headerlink" title="分配对象的处理"></a>分配对象的处理</h1><h3 id="分配对象的流程"><a href="#分配对象的流程" class="headerlink" title="分配对象的流程"></a>分配对象的流程</h3><p>go从堆分配对象时会调用newobject函数, 这个函数的流程大致如下:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165733821-1250658446.png" alt="img"></p>
<p>首先会检查GC是否在工作中, 如果GC在工作中并且当前的G分配了一定大小的内存则需要协助GC做一定的工作,<br>这个机制叫GC Assist, 用于防止分配内存太快导致GC回收跟不上的情况发生.</p>
<p>之后会判断是小对象还是大对象, 如果是大对象则直接调用largeAlloc从堆中分配,<br>如果是小对象分3个阶段获取可用的span, 然后从span中分配对象:</p>
<ul>
<li>首先从P的缓存(mcache)获取</li>
<li>然后从全局缓存(mcentral)获取, 全局缓存中有可用的span的列表</li>
<li>最后从mheap获取, mheap中也有span的自由列表, 如果都获取失败则从arena区域分配</li>
</ul>
<p>这三个阶段的详细结构如下图:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165741149-1015705312.png" alt="img"></p>
<h3 id="数据类型的定义"><a href="#数据类型的定义" class="headerlink" title="数据类型的定义"></a>数据类型的定义</h3><p>分配对象涉及的数据类型包含:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L450">p</a>: 前一篇提到过, P是协程中的用于运行go代码的虚拟资源<br><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L383">m</a>: 前一篇提到过, M目前代表系统线程<br><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L320">g</a>: 前一篇提到过, G就是goroutine<br><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L222">mspan</a>: 用于分配对象的区块<br><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L20">mcentral</a>: 全局的mspan缓存, 一共有67*2&#x3D;134个<br><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L30">mheap</a>: 用于管理heap的对象, 全局只有一个</p>
<h3 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h3><p>go从堆分配对象时会调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L840">newobject</a>函数, 先从这个函数看起:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implementation of new builtin</span></span><br><span class="line"><span class="comment">// compiler (both frontend and SSA backend) knows the signature</span></span><br><span class="line"><span class="comment">// of this function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L840">newobject</a>调用了<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L581">mallocgc</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an object of size bytes.</span></span><br><span class="line"><span class="comment">// Small objects are allocated from the per-P cache&#x27;s free lists.</span></span><br><span class="line"><span class="comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">if</span> gcphase == _GCmarktermination &#123;</span><br><span class="line">		throw(<span class="string">&quot;mallocgc called with gcphase == _GCmarktermination&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.sbrk != <span class="number">0</span> &#123;</span><br><span class="line">		align := <span class="type">uintptr</span>(<span class="number">16</span>)</span><br><span class="line">		<span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">			align = <span class="type">uintptr</span>(typ.align)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> persistentalloc(size, align, &amp;memstats.other_sys)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否要辅助GC工作</span></span><br><span class="line">	<span class="comment">// gcBlackenEnabled在GC的标记阶段会开启</span></span><br><span class="line">	<span class="comment">// assistG is the G to charge for this allocation, or nil if</span></span><br><span class="line">	<span class="comment">// GC is not currently active.</span></span><br><span class="line">	<span class="keyword">var</span> assistG *g</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Charge the current user G for this allocation.</span></span><br><span class="line">		assistG = getg()</span><br><span class="line">		<span class="keyword">if</span> assistG.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">			assistG = assistG.m.curg</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Charge the allocation against the G. We&#x27;ll account</span></span><br><span class="line">		<span class="comment">// for internal fragmentation at the end of mallocgc.</span></span><br><span class="line">		assistG.gcAssistBytes -= <span class="type">int64</span>(size)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 会按分配的大小判断需要协助GC完成多少工作</span></span><br><span class="line">		<span class="comment">// 具体的算法将在下面讲解收集器时说明</span></span><br><span class="line">		<span class="keyword">if</span> assistG.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// This G is in debt. Assist the GC to correct</span></span><br><span class="line">			<span class="comment">// this before allocating. This must happen</span></span><br><span class="line">			<span class="comment">// before disabling preemption.</span></span><br><span class="line">			gcAssistAlloc(assistG)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加当前G对应的M的lock计数, 防止这个G被抢占</span></span><br><span class="line">	<span class="comment">// Set mp.mallocing to keep from being preempted by GC.</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	<span class="keyword">if</span> mp.mallocing != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;malloc deadlock&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mp.gsignal == getg() &#123;</span><br><span class="line">		throw(<span class="string">&quot;malloc during signal&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	shouldhelpgc := <span class="literal">false</span></span><br><span class="line">	dataSize := size</span><br><span class="line">	<span class="comment">// 获取当前G对应的M对应的P的本地span缓存(mcache)</span></span><br><span class="line">	<span class="comment">// 因为M在拥有P后会把P的mcache设到M中, 这里返回的是getg().m.mcache</span></span><br><span class="line">	c := gomcache()</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	noscan := typ == <span class="literal">nil</span> || typ.kind&amp;kindNoPointers != <span class="number">0</span></span><br><span class="line">	<span class="comment">// 判断是否小对象, maxSmallSize当前的值是32K</span></span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">		<span class="comment">// 如果对象不包含指针, 并且对象的大小小于16 bytes, 可以做特殊处理</span></span><br><span class="line">		<span class="comment">// 这里是针对非常小的对象的优化, 因为span的元素最小只能是8 byte, 如果对象更小那么很多空间都会被浪费掉</span></span><br><span class="line">		<span class="comment">// 非常小的对象可以整合在&quot;class 2 noscan&quot;的元素(大小为16 byte)中</span></span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">			<span class="comment">// Tiny allocator.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Tiny allocator combines several tiny allocation requests</span></span><br><span class="line">			<span class="comment">// into a single memory block. The resulting memory block</span></span><br><span class="line">			<span class="comment">// is freed when all subobjects are unreachable. The subobjects</span></span><br><span class="line">			<span class="comment">// must be noscan (don&#x27;t have pointers), this ensures that</span></span><br><span class="line">			<span class="comment">// the amount of potentially wasted memory is bounded.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Size of the memory block used for combining (maxTinySize) is tunable.</span></span><br><span class="line">			<span class="comment">// Current setting is 16 bytes, which relates to 2x worst case memory</span></span><br><span class="line">			<span class="comment">// wastage (when all but one subobjects are unreachable).</span></span><br><span class="line">			<span class="comment">// 8 bytes would result in no wastage at all, but provides less</span></span><br><span class="line">			<span class="comment">// opportunities for combining.</span></span><br><span class="line">			<span class="comment">// 32 bytes provides more opportunities for combining,</span></span><br><span class="line">			<span class="comment">// but can lead to 4x worst case wastage.</span></span><br><span class="line">			<span class="comment">// The best case winning is 8x regardless of block size.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Objects obtained from tiny allocator must not be freed explicitly.</span></span><br><span class="line">			<span class="comment">// So when an object will be freed explicitly, we ensure that</span></span><br><span class="line">			<span class="comment">// its size &gt;= maxTinySize.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// SetFinalizer has a special case for objects potentially coming</span></span><br><span class="line">			<span class="comment">// from tiny allocator, it such case it allows to set finalizers</span></span><br><span class="line">			<span class="comment">// for an inner byte of a memory block.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// The main targets of tiny allocator are small strings and</span></span><br><span class="line">			<span class="comment">// standalone escaping variables. On a json benchmark</span></span><br><span class="line">			<span class="comment">// the allocator reduces number of allocations by ~12% and</span></span><br><span class="line">			<span class="comment">// reduces heap size by ~20%.</span></span><br><span class="line">			off := c.tinyoffset</span><br><span class="line">			<span class="comment">// Align tiny pointer for required (conservative) alignment.</span></span><br><span class="line">			<span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">8</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">4</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = round(off, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">				x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">				c.tinyoffset = off + size</span><br><span class="line">				c.local_tinyallocs++</span><br><span class="line">				mp.mallocing = <span class="number">0</span></span><br><span class="line">				releasem(mp)</span><br><span class="line">				<span class="keyword">return</span> x</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Allocate a new maxTinySize block.</span></span><br><span class="line">			span := c.alloc[tinySpanClass]</span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				v, _, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			(*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">			(*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">			<span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line">			<span class="comment">// based on amount of remaining free space.</span></span><br><span class="line">			<span class="keyword">if</span> size &lt; c.tinyoffset || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">				c.tiny = <span class="type">uintptr</span>(x)</span><br><span class="line">				c.tinyoffset = size</span><br><span class="line">			&#125;</span><br><span class="line">			size = maxTinySize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则按普通的小对象分配</span></span><br><span class="line">			<span class="comment">// 首先获取对象的大小应该使用哪个span类型</span></span><br><span class="line">			<span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">			<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">				sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			<span class="comment">// 等于sizeclass * 2 + (noscan ? 1 : 0)</span></span><br><span class="line">			spc := makeSpanClass(sizeclass, noscan)</span><br><span class="line">			span := c.alloc[spc]</span><br><span class="line">			<span class="comment">// 尝试快速的从这个span中分配</span></span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 分配失败, 可能需要从mcentral或者mheap中获取</span></span><br><span class="line">				<span class="comment">// 如果从mcentral或者mheap获取了新的span, 则shouldhelpgc会等于true</span></span><br><span class="line">				<span class="comment">// shouldhelpgc会等于true时会在下面判断是否要触发GC</span></span><br><span class="line">				v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			<span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">				memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 大对象直接从mheap分配, 这里的s是一个特殊的span, 它的class是0</span></span><br><span class="line">		<span class="keyword">var</span> s *mspan</span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			s = largeAlloc(size, needzero, noscan)</span><br><span class="line">		&#125;)</span><br><span class="line">		s.freeindex = <span class="number">1</span></span><br><span class="line">		s.allocCount = <span class="number">1</span></span><br><span class="line">		x = unsafe.Pointer(s.base())</span><br><span class="line">		size = s.elemsize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置arena对应的bitmap, 记录哪些位置包含了指针, GC会使用bitmap扫描所有可到达的对象</span></span><br><span class="line">	<span class="keyword">var</span> scanSize <span class="type">uintptr</span></span><br><span class="line">	<span class="keyword">if</span> !noscan &#123;</span><br><span class="line">		<span class="comment">// If allocating a defer+arg block, now that we&#x27;ve picked a malloc size</span></span><br><span class="line">		<span class="comment">// large enough to hold everything, cut the &quot;asked for&quot; size down to</span></span><br><span class="line">		<span class="comment">// just the defer header, so that the GC bitmap will record the arg block</span></span><br><span class="line">		<span class="comment">// as containing nothing at all (as if it were unused space at the end of</span></span><br><span class="line">		<span class="comment">// a malloc block caused by size rounding).</span></span><br><span class="line">		<span class="comment">// The defer arg areas are scanned as part of scanstack.</span></span><br><span class="line">		<span class="keyword">if</span> typ == deferType &#123;</span><br><span class="line">			dataSize = unsafe.Sizeof(_defer&#123;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这个函数非常的长, 有兴趣的可以看</span></span><br><span class="line">		<span class="comment">// https://github.com/golang/go/blob/go1.9.2/src/runtime/mbitmap.go#L855</span></span><br><span class="line">		<span class="comment">// 虽然代码很长但是设置的内容跟上面说过的bitmap区域的结构一样</span></span><br><span class="line">		<span class="comment">// 根据类型信息设置scan bit跟pointer bit, scan bit成立表示应该继续扫描, pointer bit成立表示该位置是指针</span></span><br><span class="line">		<span class="comment">// 需要注意的地方有</span></span><br><span class="line">		<span class="comment">// - 如果一个类型只有开头的地方包含指针, 例如[ptr, ptr, large non-pointer data]</span></span><br><span class="line">		<span class="comment">//   那么后面的部分的scan bit将会为0, 这样可以大幅提升标记的效率</span></span><br><span class="line">		<span class="comment">// - 第二个slot的scan bit用途比较特殊, 它并不用于标记是否继续scan, 而是标记checkmark</span></span><br><span class="line">		<span class="comment">// 什么是checkmark</span></span><br><span class="line">		<span class="comment">// - 因为go的并行GC比较复杂, 为了检查实现是否正确, go需要在有一个检查所有应该被标记的对象是否被标记的机制</span></span><br><span class="line">		<span class="comment">//   这个机制就是checkmark, 在开启checkmark时go会在标记阶段的最后停止整个世界然后重新执行一次标记</span></span><br><span class="line">		<span class="comment">//   上面的第二个slot的scan bit就是用于标记对象在checkmark标记中是否被标记的</span></span><br><span class="line">		<span class="comment">// - 有的人可能会发现第二个slot要求对象最少有两个指针的大小, 那么只有一个指针的大小的对象呢?</span></span><br><span class="line">		<span class="comment">//   只有一个指针的大小的对象可以分为两种情况</span></span><br><span class="line">		<span class="comment">//   对象就是指针, 因为大小刚好是1个指针所以并不需要看bitmap区域, 这时第一个slot就是checkmark</span></span><br><span class="line">		<span class="comment">//   对象不是指针, 因为有tiny alloc的机制, 不是指针且只有一个指针大小的对象会分配在两个指针的span中</span></span><br><span class="line">		<span class="comment">//               这时候也不需要看bitmap区域, 所以和上面一样第一个slot就是checkmark</span></span><br><span class="line">		heapBitsSetType(<span class="type">uintptr</span>(x), size, dataSize, typ)</span><br><span class="line">		<span class="keyword">if</span> dataSize &gt; typ.size &#123;</span><br><span class="line">			<span class="comment">// Array allocation. If there are any</span></span><br><span class="line">			<span class="comment">// pointers, GC has to scan to the last</span></span><br><span class="line">			<span class="comment">// element.</span></span><br><span class="line">			<span class="keyword">if</span> typ.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				scanSize = dataSize - typ.size + typ.ptrdata</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			scanSize = typ.ptrdata</span><br><span class="line">		&#125;</span><br><span class="line">		c.local_scan += scanSize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内存屏障, 因为x86和x64的store不会乱序所以这里只是个针对编译器的屏障, 汇编中是ret</span></span><br><span class="line">	<span class="comment">// Ensure that the stores above that initialize x to</span></span><br><span class="line">	<span class="comment">// type-safe memory and set the heap bits occur before</span></span><br><span class="line">	<span class="comment">// the caller can make x observable to the garbage</span></span><br><span class="line">	<span class="comment">// collector. Otherwise, on weakly ordered machines,</span></span><br><span class="line">	<span class="comment">// the garbage collector could follow a pointer to x,</span></span><br><span class="line">	<span class="comment">// but see uninitialized memory or stale heap bits.</span></span><br><span class="line">	publicationBarrier()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前在GC中, 需要立刻标记分配后的对象为&quot;黑色&quot;, 防止它被回收</span></span><br><span class="line">	<span class="comment">// Allocate black during GC.</span></span><br><span class="line">	<span class="comment">// All slots hold nil so no scanning is needed.</span></span><br><span class="line">	<span class="comment">// This may be racing with GC so do it atomically if there can be</span></span><br><span class="line">	<span class="comment">// a race marking the bit.</span></span><br><span class="line">	<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">		gcmarknewobject(<span class="type">uintptr</span>(x), size, scanSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Race Detector的处理(用于检测线程冲突问题)</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racemalloc(x, size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Memory Sanitizer的处理(用于检测危险指针等内存问题)</span></span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanmalloc(x, size)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新允许当前的G被抢占</span></span><br><span class="line">	mp.mallocing = <span class="number">0</span></span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 除错记录</span></span><br><span class="line">	<span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> &#123;</span><br><span class="line">		tracealloc(x, size, typ)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Profiler记录</span></span><br><span class="line">	<span class="keyword">if</span> rate := MemProfileRate; rate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> size &lt; <span class="type">uintptr</span>(rate) &amp;&amp; <span class="type">int32</span>(size) &lt; c.next_sample &#123;</span><br><span class="line">			c.next_sample -= <span class="type">int32</span>(size)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mp := acquirem()</span><br><span class="line">			profilealloc(mp, x, size)</span><br><span class="line">			releasem(mp)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcAssistBytes减去&quot;实际分配大小 - 要求分配大小&quot;, 调整到准确值</span></span><br><span class="line">	<span class="keyword">if</span> assistG != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Account for internal fragmentation in the assist</span></span><br><span class="line">		<span class="comment">// debt now that we know it.</span></span><br><span class="line">		assistG.gcAssistBytes -= <span class="type">int64</span>(size - dataSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果之前获取了新的span, 则判断是否需要后台启动GC</span></span><br><span class="line">	<span class="comment">// 这里的判断逻辑(gcTrigger)会在下面详细说明</span></span><br><span class="line">	<span class="keyword">if</span> shouldhelpgc &#123;</span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">			gcStart(gcBackgroundMode, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看如何从span里面分配对象, 首先会调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L521">nextFreeFast</a>尝试快速分配:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFreeFast returns the next free object if one is quickly available.</span></span><br><span class="line"><span class="comment">// Otherwise it returns 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span></span> gclinkptr &#123;</span><br><span class="line">	<span class="comment">// 获取第一个非0的bit是第几个bit, 也就是哪个元素是未分配的</span></span><br><span class="line">	theBit := sys.Ctz64(s.allocCache) <span class="comment">// Is there a free object in the allocCache?</span></span><br><span class="line">	<span class="comment">// 找到未分配的元素</span></span><br><span class="line">	<span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">		result := s.freeindex + <span class="type">uintptr</span>(theBit)</span><br><span class="line">		<span class="comment">// 要求索引值小于元素数量</span></span><br><span class="line">		<span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">			<span class="comment">// 下一个freeindex</span></span><br><span class="line">			freeidx := result + <span class="number">1</span></span><br><span class="line">			<span class="comment">// 可以被64整除时需要特殊处理(参考nextFree)</span></span><br><span class="line">			<span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 更新freeindex和allocCache(高位都是0, 用尽以后会更新)</span></span><br><span class="line">			s.allocCache &gt;&gt;= <span class="type">uint</span>(theBit + <span class="number">1</span>)</span><br><span class="line">			s.freeindex = freeidx</span><br><span class="line">			<span class="comment">// 返回元素所在的地址</span></span><br><span class="line">			v := gclinkptr(result*s.elemsize + s.base())</span><br><span class="line">			<span class="comment">// 添加已分配的元素计数</span></span><br><span class="line">			s.allocCount++</span><br><span class="line">			<span class="keyword">return</span> v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在freeindex后无法快速找到未分配的元素, 就需要调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L546">nextFree</a>做出更复杂的处理:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nextFree returns the next free object from the cached span if one is available.</span></span><br><span class="line"><span class="comment">// Otherwise it refills the cache with a span with an available object and</span></span><br><span class="line"><span class="comment">// returns that object along with a flag indicating that this was a heavy</span></span><br><span class="line"><span class="comment">// weight allocation. If it is a heavy weight allocation the caller must</span></span><br><span class="line"><span class="comment">// determine whether a new GC cycle needs to be started or if the GC is active</span></span><br><span class="line"><span class="comment">// whether this goroutine needs to assist the GC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 找到下一个freeindex和更新allocCache</span></span><br><span class="line">	s = c.alloc[spc]</span><br><span class="line">	shouldhelpgc = <span class="literal">false</span></span><br><span class="line">	freeIndex := s.nextFreeIndex()</span><br><span class="line">	<span class="comment">// 如果span里面所有元素都已分配, 则需要获取新的span</span></span><br><span class="line">	<span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">		<span class="comment">// The span is full.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">			throw(<span class="string">&quot;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 申请新的span</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.refill(spc)</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">// 获取申请后的新的span, 并设置需要检查是否执行GC</span></span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">		freeIndex = s.nextFreeIndex()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;freeIndex is not valid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回元素所在的地址</span></span><br><span class="line">	v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">	<span class="comment">// 添加已分配的元素计数</span></span><br><span class="line">	s.allocCount++</span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) &gt; s.nelems &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">		throw(<span class="string">&quot;s.allocCount &gt; s.nelems&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果mcache中指定类型的span已满, 就需要调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcache.go#L107">refill</a>函数申请新的span:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gets a span that has a free object in it and assigns it</span></span><br><span class="line"><span class="comment">// to be the cached span for the given sizeclass. Returns this span.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> refill(spc spanClass) *mspan &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 防止G被抢占</span></span><br><span class="line">	_g_.m.locks++</span><br><span class="line">	<span class="comment">// Return the current cached span to the central lists.</span></span><br><span class="line">	s := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保当前的span所有元素都已分配</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;refill of span with free space remaining&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置span的incache属性, 除非是全局使用的空span(也就是mcache里面span指针的默认值)</span></span><br><span class="line">	<span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">		s.incache = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向mcentral申请一个新的span</span></span><br><span class="line">	<span class="comment">// Get a new cached span from the central lists.</span></span><br><span class="line">	s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;span has no free space&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新的span到mcache中</span></span><br><span class="line">	c.alloc[spc] = s</span><br><span class="line">	<span class="comment">// 允许G被抢占</span></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向mcentral申请一个新的span会通过<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L40">cacheSpan</a>函数:<br>mcentral首先尝试从内部的链表复用原有的span, 如果复用失败则向mheap申请.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a span to use in an MCache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">	<span class="comment">// 让当前G协助一部分的sweep工作</span></span><br><span class="line">	<span class="comment">// Deduct credit for this span allocation and sweep if necessary.</span></span><br><span class="line">	spanBytes := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize</span><br><span class="line">	deductSweepCredit(spanBytes, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对mcentral上锁, 因为可能会有多个M(P)同时访问</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	traceDone := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepStart()</span><br><span class="line">	&#125;</span><br><span class="line">	sg := mheap_.sweepgen</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">// mcentral里面有两个span的链表</span></span><br><span class="line">	<span class="comment">// - nonempty表示确定该span最少有一个未分配的元素</span></span><br><span class="line">	<span class="comment">// - empty表示不确定该span最少有一个未分配的元素</span></span><br><span class="line">	<span class="comment">// 这里优先查找nonempty的链表</span></span><br><span class="line">	<span class="comment">// sweepgen每次GC都会增加2</span></span><br><span class="line">	<span class="comment">// - sweepgen == 全局sweepgen, 表示span已经sweep过</span></span><br><span class="line">	<span class="comment">// - sweepgen == 全局sweepgen-1, 表示span正在sweep</span></span><br><span class="line">	<span class="comment">// - sweepgen == 全局sweepgen-2, 表示span等待sweep</span></span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">	<span class="keyword">for</span> s = c.nonempty.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">		<span class="comment">// 如果span等待sweep, 尝试原子修改sweepgen为全局sweepgen-1</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">// 修改成功则把span移到empty链表, sweep它然后跳到havespan</span></span><br><span class="line">			c.nonempty.remove(s)</span><br><span class="line">			c.empty.insertBack(s)</span><br><span class="line">			unlock(&amp;c.lock)</span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">			<span class="keyword">goto</span> havespan</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果这个span正在被其他线程sweep, 就跳过</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">// the span is being swept by background sweeper, skip</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// span已经sweep过</span></span><br><span class="line">		<span class="comment">// 因为nonempty链表中的span确定最少有一个未分配的元素, 这里可以直接使用它</span></span><br><span class="line">		<span class="comment">// we have a nonempty span that does not require sweeping, allocate from it</span></span><br><span class="line">		c.nonempty.remove(s)</span><br><span class="line">		c.empty.insertBack(s)</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">goto</span> havespan</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找empty的链表</span></span><br><span class="line">	<span class="keyword">for</span> s = c.empty.first; s != <span class="literal">nil</span>; s = s.next &#123;</span><br><span class="line">		<span class="comment">// 如果span等待sweep, 尝试原子修改sweepgen为全局sweepgen-1</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">// 把span放到empty链表的最后</span></span><br><span class="line">			<span class="comment">// we have an empty span that requires sweeping,</span></span><br><span class="line">			<span class="comment">// sweep it and see if we can free some space in it</span></span><br><span class="line">			c.empty.remove(s)</span><br><span class="line">			<span class="comment">// swept spans are at the end of the list</span></span><br><span class="line">			c.empty.insertBack(s)</span><br><span class="line">			unlock(&amp;c.lock)</span><br><span class="line">			<span class="comment">// 尝试sweep</span></span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">			<span class="comment">// sweep以后还需要检测是否有未分配的对象, 如果有则可以使用它</span></span><br><span class="line">			freeIndex := s.nextFreeIndex()</span><br><span class="line">			<span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">				s.freeindex = freeIndex</span><br><span class="line">				<span class="keyword">goto</span> havespan</span><br><span class="line">			&#125;</span><br><span class="line">			lock(&amp;c.lock)</span><br><span class="line">			<span class="comment">// the span is still empty after sweep</span></span><br><span class="line">			<span class="comment">// it is already in the empty list, so just retry</span></span><br><span class="line">			<span class="keyword">goto</span> retry</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果这个span正在被其他线程sweep, 就跳过</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="comment">// the span is being swept by background sweeper, skip</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找不到有未分配对象的span</span></span><br><span class="line">		<span class="comment">// already swept empty span,</span></span><br><span class="line">		<span class="comment">// all subsequent ones must also be either swept or in process of sweeping</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepDone()</span><br><span class="line">		traceDone = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找不到有未分配对象的span, 需要从mheap分配</span></span><br><span class="line">	<span class="comment">// 分配完成后加到empty链表中</span></span><br><span class="line">	<span class="comment">// Replenish central list if empty.</span></span><br><span class="line">	s = c.grow()</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	c.empty.insertBack(s)</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// At this point s is a non-empty span, queued at the end of the empty list,</span></span><br><span class="line">	<span class="comment">// c is unlocked.</span></span><br><span class="line">havespan:</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &amp;&amp; !traceDone &#123;</span><br><span class="line">		traceGCSweepDone()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 统计span中未分配的元素数量, 加到mcentral.nmalloc中</span></span><br><span class="line">	<span class="comment">// 统计span中未分配的元素总大小, 加到memstats.heap_live中</span></span><br><span class="line">	<span class="built_in">cap</span> := <span class="type">int32</span>((s.npages &lt;&lt; _PageShift) / s.elemsize)</span><br><span class="line">	n := <span class="built_in">cap</span> - <span class="type">int32</span>(s.allocCount)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> || s.freeindex == s.nelems || <span class="type">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;span has no free objects&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Assume all objects from this span will be allocated in the</span></span><br><span class="line">	<span class="comment">// mcache. If it gets uncached, we&#x27;ll adjust this.</span></span><br><span class="line">	atomic.Xadd64(&amp;c.nmalloc, <span class="type">int64</span>(n))</span><br><span class="line">	usedBytes := <span class="type">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class="line">	atomic.Xadd64(&amp;memstats.heap_live, <span class="type">int64</span>(spanBytes)-<span class="type">int64</span>(usedBytes))</span><br><span class="line">	<span class="comment">// 跟踪处理</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		<span class="comment">// heap_live changed.</span></span><br><span class="line">		traceHeapAlloc()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果当前在GC中, 因为heap_live改变了, 重新调整G辅助标记工作的值</span></span><br><span class="line">	<span class="comment">// 详细请参考下面对revise函数的解析</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// heap_live changed.</span></span><br><span class="line">		gcController.revise()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置span的incache属性, 表示span正在mcache中</span></span><br><span class="line">	s.incache = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// 根据freeindex更新allocCache</span></span><br><span class="line">	freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">	whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">	<span class="comment">// Init alloc bits cache.</span></span><br><span class="line">	s.refillAllocCache(whichByte)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust the allocCache so that s.freeindex corresponds to the low bit in</span></span><br><span class="line">	<span class="comment">// s.allocCache.</span></span><br><span class="line">	s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mcentral向mheap申请一个新的span会使用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mcentral.go#L227">grow</a>函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// grow allocates a new empty span from the heap and initializes it for c&#x27;s size class.</span><br><span class="line">func (c *mcentral) grow() *mspan &#123;</span><br><span class="line">	// 根据mcentral的类型计算需要申请的span的大小(除以8K = 有多少页)和可以保存多少个元素</span><br><span class="line">	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">	size := uintptr(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line">	n := (npages &lt;&lt; _PageShift) / size</span><br><span class="line"></span><br><span class="line">	// 向mheap申请一个新的span, 以页(8K)为单位</span><br><span class="line">	s := mheap_.alloc(npages, c.spanclass, false, true)</span><br><span class="line">	if s == nil &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p := s.base()</span><br><span class="line">	s.limit = p + size*n</span><br><span class="line"></span><br><span class="line">	// 分配并初始化span的allocBits和gcmarkBits</span><br><span class="line">	heapBitsForSpan(s.base()).initSpan(s)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mheap分配span的函数是<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L727">alloc</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc(npage <span class="type">uintptr</span>, spanclass spanClass, large <span class="type">bool</span>, needzero <span class="type">bool</span>) *mspan &#123;</span><br><span class="line">	<span class="comment">// 在g0的栈空间中调用alloc_m函数</span></span><br><span class="line">	<span class="comment">// 关于systemstack的说明请看前一篇文章</span></span><br><span class="line">	<span class="comment">// Don&#x27;t do any operations that lock the heap on the G stack.</span></span><br><span class="line">	<span class="comment">// It might trigger stack growth, and the stack growth code needs</span></span><br><span class="line">	<span class="comment">// to be able to allocate heap.</span></span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s = h.alloc_m(npage, spanclass, large)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> needzero &amp;&amp; s.needzero != <span class="number">0</span> &#123;</span><br><span class="line">			memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class="line">		&#125;</span><br><span class="line">		s.needzero = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>alloc函数会在g0的栈空间中调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L634">alloc_m</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a new span of npage pages from the heap for GC&#x27;d memory</span></span><br><span class="line"><span class="comment">// and record its size class in the HeapMap and HeapMapCache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc_m(npage <span class="type">uintptr</span>, spanclass spanClass, large <span class="type">bool</span>) *mspan &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">		throw(<span class="string">&quot;_mheap_alloc not on g0 stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对mheap上锁, 这里的锁是全局锁</span></span><br><span class="line">	lock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了防止heap增速太快, 在分配n页之前要先sweep和回收n页</span></span><br><span class="line">	<span class="comment">// 会先枚举busy列表然后再枚举busyLarge列表进行sweep, 具体参考reclaim和reclaimList函数</span></span><br><span class="line">	<span class="comment">// To prevent excessive heap growth, before allocating n pages</span></span><br><span class="line">	<span class="comment">// we need to sweep and reclaim at least n pages.</span></span><br><span class="line">	<span class="keyword">if</span> h.sweepdone == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// TODO(austin): This tends to sweep a large number of</span></span><br><span class="line">		<span class="comment">// spans in order to find a few completely free spans</span></span><br><span class="line">		<span class="comment">// (for example, in the garbage benchmark, this sweeps</span></span><br><span class="line">		<span class="comment">// ~30x the number of pages its trying to allocate).</span></span><br><span class="line">		<span class="comment">// If GC kept a bit for whether there were any marks</span></span><br><span class="line">		<span class="comment">// in a span, we could release these free spans</span></span><br><span class="line">		<span class="comment">// at the end of GC and eliminate this entirely.</span></span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGCSweepStart()</span><br><span class="line">		&#125;</span><br><span class="line">		h.reclaim(npage)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGCSweepDone()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把mcache中的本地统计数据加到全局</span></span><br><span class="line">	<span class="comment">// transfer stats from cache to global</span></span><br><span class="line">	memstats.heap_scan += <span class="type">uint64</span>(_g_.m.mcache.local_scan)</span><br><span class="line">	_g_.m.mcache.local_scan = <span class="number">0</span></span><br><span class="line">	memstats.tinyallocs += <span class="type">uint64</span>(_g_.m.mcache.local_tinyallocs)</span><br><span class="line">	_g_.m.mcache.local_tinyallocs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用allocSpanLocked分配span, allocSpanLocked函数要求当前已经对mheap上锁</span></span><br><span class="line">	s := h.allocSpanLocked(npage, &amp;memstats.heap_inuse)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Record span info, because gc needs to be</span></span><br><span class="line">		<span class="comment">// able to map interior pointer to containing span.</span></span><br><span class="line">		<span class="comment">// 设置span的sweepgen = 全局sweepgen</span></span><br><span class="line">		atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line">		<span class="comment">// 放到全局span列表中, 这里的sweepSpans的长度是2</span></span><br><span class="line">		<span class="comment">// sweepSpans[h.sweepgen/2%2]保存当前正在使用的span列表</span></span><br><span class="line">		<span class="comment">// sweepSpans[1-h.sweepgen/2%2]保存等待sweep的span列表</span></span><br><span class="line">		<span class="comment">// 因为每次gcsweepgen都会加2, 每次gc这两个列表都会交换</span></span><br><span class="line">		h.sweepSpans[h.sweepgen/<span class="number">2</span>%<span class="number">2</span>].push(s) <span class="comment">// Add to swept in-use list.</span></span><br><span class="line">		<span class="comment">// 初始化span成员</span></span><br><span class="line">		s.state = _MSpanInUse</span><br><span class="line">		s.allocCount = <span class="number">0</span></span><br><span class="line">		s.spanclass = spanclass</span><br><span class="line">		<span class="keyword">if</span> sizeclass := spanclass.sizeclass(); sizeclass == <span class="number">0</span> &#123;</span><br><span class="line">			s.elemsize = s.npages &lt;&lt; _PageShift</span><br><span class="line">			s.divShift = <span class="number">0</span></span><br><span class="line">			s.divMul = <span class="number">0</span></span><br><span class="line">			s.divShift2 = <span class="number">0</span></span><br><span class="line">			s.baseMask = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s.elemsize = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			m := &amp;class_to_divmagic[sizeclass]</span><br><span class="line">			s.divShift = m.shift</span><br><span class="line">			s.divMul = m.mul</span><br><span class="line">			s.divShift2 = m.shift2</span><br><span class="line">			s.baseMask = m.baseMask</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// update stats, sweep lists</span></span><br><span class="line">		h.pagesInUse += <span class="type">uint64</span>(npage)</span><br><span class="line">		<span class="comment">// 上面grow函数会传入true, 也就是通过grow调用到这里large会等于true</span></span><br><span class="line">		<span class="comment">// 添加已分配的span到busy列表, 如果页数超过_MaxMHeapList(128页=8K*128=1M)则放到busylarge列表</span></span><br><span class="line">		<span class="keyword">if</span> large &#123;</span><br><span class="line">			memstats.heap_objects++</span><br><span class="line">			mheap_.largealloc += <span class="type">uint64</span>(s.elemsize)</span><br><span class="line">			mheap_.nlargealloc++</span><br><span class="line">			atomic.Xadd64(&amp;memstats.heap_live, <span class="type">int64</span>(npage&lt;&lt;_PageShift))</span><br><span class="line">			<span class="comment">// Swept spans are at the end of lists.</span></span><br><span class="line">			<span class="keyword">if</span> s.npages &lt; <span class="type">uintptr</span>(<span class="built_in">len</span>(h.busy)) &#123;</span><br><span class="line">				h.busy[s.npages].insertBack(s)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				h.busylarge.insertBack(s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果当前在GC中, 因为heap_live改变了, 重新调整G辅助标记工作的值</span></span><br><span class="line">	<span class="comment">// 详细请参考下面对revise函数的解析</span></span><br><span class="line">	<span class="comment">// heap_scan and heap_live were updated.</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		gcController.revise()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跟踪处理</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceHeapAlloc()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// h.spans is accessed concurrently without synchronization</span></span><br><span class="line">	<span class="comment">// from other threads. Hence, there must be a store/store</span></span><br><span class="line">	<span class="comment">// barrier here to ensure the writes to h.spans above happen</span></span><br><span class="line">	<span class="comment">// before the caller can publish a pointer p to an object</span></span><br><span class="line">	<span class="comment">// allocated from s. As soon as this happens, the garbage</span></span><br><span class="line">	<span class="comment">// collector running on another processor could read p and</span></span><br><span class="line">	<span class="comment">// look up s in h.spans. The unlock acts as the barrier to</span></span><br><span class="line">	<span class="comment">// order these writes. On the read side, the data dependency</span></span><br><span class="line">	<span class="comment">// between p and the index in h.spans orders the reads.</span></span><br><span class="line">	unlock(&amp;h.lock)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L784">allocSpanLocked</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocates a span of the given size.  h must be locked.</span></span><br><span class="line"><span class="comment">// The returned span has been removed from the</span></span><br><span class="line"><span class="comment">// free list, but its state is still MSpanFree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpanLocked(npage <span class="type">uintptr</span>, stat *<span class="type">uint64</span>) *mspan &#123;</span><br><span class="line">	<span class="keyword">var</span> list *mSpanList</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试在mheap中的自由列表分配</span></span><br><span class="line">	<span class="comment">// 页数小于_MaxMHeapList(128页=1M)的自由span都会在free列表中</span></span><br><span class="line">	<span class="comment">// 页数大于_MaxMHeapList的自由span都会在freelarge列表中</span></span><br><span class="line">	<span class="comment">// Try in fixed-size lists up to max.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">int</span>(npage); i &lt; <span class="built_in">len</span>(h.free); i++ &#123;</span><br><span class="line">		list = &amp;h.free[i]</span><br><span class="line">		<span class="keyword">if</span> !list.isEmpty() &#123;</span><br><span class="line">			s = list.first</span><br><span class="line">			list.remove(s)</span><br><span class="line">			<span class="keyword">goto</span> HaveSpan</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// free列表找不到则查找freelarge列表</span></span><br><span class="line">	<span class="comment">// 查找不到就向arena区域申请一个新的span加到freelarge中, 然后再查找freelarge列表</span></span><br><span class="line">	<span class="comment">// Best fit in list of large spans.</span></span><br><span class="line">	s = h.allocLarge(npage) <span class="comment">// allocLarge removed s from h.freelarge for us</span></span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !h.grow(npage) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		s = h.allocLarge(npage)</span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">	<span class="comment">// Mark span in use.</span></span><br><span class="line">	<span class="keyword">if</span> s.state != _MSpanFree &#123;</span><br><span class="line">		throw(<span class="string">&quot;MHeap_AllocLocked - MSpan not free&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.npages &lt; npage &#123;</span><br><span class="line">		throw(<span class="string">&quot;MHeap_AllocLocked - bad npages&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果span有已释放(解除虚拟内存和物理内存关系)的页, 提醒这些页会被使用然后更新统计数据</span></span><br><span class="line">	<span class="keyword">if</span> s.npreleased &gt; <span class="number">0</span> &#123;</span><br><span class="line">		sysUsed(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class="line">		memstats.heap_released -= <span class="type">uint64</span>(s.npreleased &lt;&lt; _PageShift)</span><br><span class="line">		s.npreleased = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果获取到的span页数比要求的页数多</span></span><br><span class="line">	<span class="comment">// 分割剩余的页数到另一个span并且放到自由列表中</span></span><br><span class="line">	<span class="keyword">if</span> s.npages &gt; npage &#123;</span><br><span class="line">		<span class="comment">// Trim extra and put it back in the heap.</span></span><br><span class="line">		t := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">		t.init(s.base()+npage&lt;&lt;_PageShift, s.npages-npage)</span><br><span class="line">		s.npages = npage</span><br><span class="line">		p := (t.base() - h.arena_start) &gt;&gt; _PageShift</span><br><span class="line">		<span class="keyword">if</span> p &gt; <span class="number">0</span> &#123;</span><br><span class="line">			h.spans[p<span class="number">-1</span>] = s</span><br><span class="line">		&#125;</span><br><span class="line">		h.spans[p] = t</span><br><span class="line">		h.spans[p+t.npages<span class="number">-1</span>] = t</span><br><span class="line">		t.needzero = s.needzero</span><br><span class="line">		s.state = _MSpanManual <span class="comment">// prevent coalescing with s</span></span><br><span class="line">		t.state = _MSpanManual</span><br><span class="line">		h.freeSpanLocked(t, <span class="literal">false</span>, <span class="literal">false</span>, s.unusedsince)</span><br><span class="line">		s.state = _MSpanFree</span><br><span class="line">	&#125;</span><br><span class="line">	s.unusedsince = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置spans区域, 哪些地址对应哪个mspan对象</span></span><br><span class="line">	p := (s.base() - h.arena_start) &gt;&gt; _PageShift</span><br><span class="line">	<span class="keyword">for</span> n := <span class="type">uintptr</span>(<span class="number">0</span>); n &lt; npage; n++ &#123;</span><br><span class="line">		h.spans[p+n] = s</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新统计数据</span></span><br><span class="line">	*stat += <span class="type">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class="line">	memstats.heap_idle -= <span class="type">uint64</span>(npage &lt;&lt; _PageShift)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//println(&quot;spanalloc&quot;, hex(s.start&lt;&lt;_PageShift))</span></span><br><span class="line">	<span class="keyword">if</span> s.inList() &#123;</span><br><span class="line">		throw(<span class="string">&quot;still in list&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L867">allocLarge</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocLarge allocates a span of at least npage pages from the treap of large spans.</span></span><br><span class="line"><span class="comment">// Returns nil if no such span currently exists.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocLarge(npage <span class="type">uintptr</span>) *mspan &#123;</span><br><span class="line">	<span class="comment">// Search treap for smallest span with &gt;= npage pages.</span></span><br><span class="line">	<span class="keyword">return</span> h.freelarge.remove(npage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freelarge的类型是mTreap, 调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgclarge.go#L205">remove</a>函数会在树里面搜索一个至少npage且在树中的最小的span返回:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove searches for, finds, removes from the treap, and returns the smallest</span></span><br><span class="line"><span class="comment">// span that can hold npages. If no span has at least npages return nil.</span></span><br><span class="line"><span class="comment">// This is slightly more complicated than a simple binary tree search</span></span><br><span class="line"><span class="comment">// since if an exact match is not found the next larger node is</span></span><br><span class="line"><span class="comment">// returned.</span></span><br><span class="line"><span class="comment">// If the last node inspected &gt; npagesKey not holding</span></span><br><span class="line"><span class="comment">// a left node (a smaller npages) is the &quot;best fit&quot; node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *mTreap)</span></span> remove(npages <span class="type">uintptr</span>) *mspan &#123;</span><br><span class="line">	t := root.treap</span><br><span class="line">	<span class="keyword">for</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.spanKey == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;treap node with nil spanKey found&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> t.npagesKey &lt; npages &#123;</span><br><span class="line">			t = t.right</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.left != <span class="literal">nil</span> &amp;&amp; t.left.npagesKey &gt;= npages &#123;</span><br><span class="line">			t = t.left</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result := t.spanKey</span><br><span class="line">			root.removeNode(t)</span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向arena区域申请新span的函数是mheap类的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mheap.go#L876">grow</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to add at least npage pages of memory to the heap,</span></span><br><span class="line"><span class="comment">// returning whether it worked.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// h must be locked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> grow(npage <span class="type">uintptr</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// Ask for a big chunk, to reduce the number of mappings</span></span><br><span class="line">	<span class="comment">// the operating system needs to track; also amortizes</span></span><br><span class="line">	<span class="comment">// the overhead of an operating system mapping.</span></span><br><span class="line">	<span class="comment">// Allocate a multiple of 64kB.</span></span><br><span class="line">	npage = round(npage, (<span class="number">64</span>&lt;&lt;<span class="number">10</span>)/_PageSize)</span><br><span class="line">	ask := npage &lt;&lt; _PageShift</span><br><span class="line">	<span class="keyword">if</span> ask &lt; _HeapAllocChunk &#123;</span><br><span class="line">		ask = _HeapAllocChunk</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用mheap.sysAlloc函数申请</span></span><br><span class="line">	v := h.sysAlloc(ask)</span><br><span class="line">	<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ask &gt; npage&lt;&lt;_PageShift &#123;</span><br><span class="line">			ask = npage &lt;&lt; _PageShift</span><br><span class="line">			v = h.sysAlloc(ask)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: out of memory: cannot allocate &quot;</span>, ask, <span class="string">&quot;-byte block (&quot;</span>, memstats.heap_sys, <span class="string">&quot; in use)\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个新的span并加到自由列表中</span></span><br><span class="line">	<span class="comment">// Create a fake &quot;in use&quot; span and free it, so that the</span></span><br><span class="line">	<span class="comment">// right coalescing happens.</span></span><br><span class="line">	s := (*mspan)(h.spanalloc.alloc())</span><br><span class="line">	s.init(<span class="type">uintptr</span>(v), ask&gt;&gt;_PageShift)</span><br><span class="line">	p := (s.base() - h.arena_start) &gt;&gt; _PageShift</span><br><span class="line">	<span class="keyword">for</span> i := p; i &lt; p+s.npages; i++ &#123;</span><br><span class="line">		h.spans[i] = s</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line">	s.state = _MSpanInUse</span><br><span class="line">	h.pagesInUse += <span class="type">uint64</span>(s.npages)</span><br><span class="line">	h.freeSpanLocked(s, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续查看mheap的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/malloc.go#L401">sysAlloc</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysAlloc allocates the next n bytes from the heap arena. The</span></span><br><span class="line"><span class="comment">// returned pointer is always _PageSize aligned and between</span></span><br><span class="line"><span class="comment">// h.arena_start and h.arena_end. sysAlloc returns nil on failure.</span></span><br><span class="line"><span class="comment">// There is no corresponding free function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> sysAlloc(n <span class="type">uintptr</span>) unsafe.Pointer &#123;</span><br><span class="line">	<span class="comment">// strandLimit is the maximum number of bytes to strand from</span></span><br><span class="line">	<span class="comment">// the current arena block. If we would need to strand more</span></span><br><span class="line">	<span class="comment">// than this, we fall back to sysAlloc&#x27;ing just enough for</span></span><br><span class="line">	<span class="comment">// this allocation.</span></span><br><span class="line">	<span class="keyword">const</span> strandLimit = <span class="number">16</span> &lt;&lt; <span class="number">20</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果arena区域当前已提交的区域不足, 则调用sysReserve预留更多的空间, 然后更新arena_end</span></span><br><span class="line">	<span class="comment">// sysReserve在linux上调用的是mmap函数</span></span><br><span class="line">	<span class="comment">// mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; h.arena_end-h.arena_alloc &#123;</span><br><span class="line">		<span class="comment">// If we haven&#x27;t grown the arena to _MaxMem yet, try</span></span><br><span class="line">		<span class="comment">// to reserve some more address space.</span></span><br><span class="line">		p_size := round(n+_PageSize, <span class="number">256</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">		new_end := h.arena_end + p_size <span class="comment">// Careful: can overflow</span></span><br><span class="line">		<span class="keyword">if</span> h.arena_end &lt;= new_end &amp;&amp; new_end-h.arena_start<span class="number">-1</span> &lt;= _MaxMem &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> It would be bad if part of the arena</span></span><br><span class="line">			<span class="comment">// is reserved and part is not.</span></span><br><span class="line">			<span class="keyword">var</span> reserved <span class="type">bool</span></span><br><span class="line">			p := <span class="type">uintptr</span>(sysReserve(unsafe.Pointer(h.arena_end), p_size, &amp;reserved))</span><br><span class="line">			<span class="keyword">if</span> p == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> Try smaller reservation</span></span><br><span class="line">				<span class="comment">// growths in case we&#x27;re in a crowded</span></span><br><span class="line">				<span class="comment">// 32-bit address space.</span></span><br><span class="line">				<span class="keyword">goto</span> reservationFailed</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// p can be just about anywhere in the address</span></span><br><span class="line">			<span class="comment">// space, including before arena_end.</span></span><br><span class="line">			<span class="keyword">if</span> p == h.arena_end &#123;</span><br><span class="line">				<span class="comment">// The new block is contiguous with</span></span><br><span class="line">				<span class="comment">// the current block. Extend the</span></span><br><span class="line">				<span class="comment">// current arena block.</span></span><br><span class="line">				h.arena_end = new_end</span><br><span class="line">				h.arena_reserved = reserved</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> h.arena_start &lt;= p &amp;&amp; p+p_size-h.arena_start<span class="number">-1</span> &lt;= _MaxMem &amp;&amp; h.arena_end-h.arena_alloc &lt; strandLimit &#123;</span><br><span class="line">				<span class="comment">// We were able to reserve more memory</span></span><br><span class="line">				<span class="comment">// within the arena space, but it&#x27;s</span></span><br><span class="line">				<span class="comment">// not contiguous with our previous</span></span><br><span class="line">				<span class="comment">// reservation. It could be before or</span></span><br><span class="line">				<span class="comment">// after our current arena_used.</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// Keep everything page-aligned.</span></span><br><span class="line">				<span class="comment">// Our pages are bigger than hardware pages.</span></span><br><span class="line">				h.arena_end = p + p_size</span><br><span class="line">				p = round(p, _PageSize)</span><br><span class="line">				h.arena_alloc = p</span><br><span class="line">				h.arena_reserved = reserved</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// We got a mapping, but either</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// 1) It&#x27;s not in the arena, so we</span></span><br><span class="line">				<span class="comment">// can&#x27;t use it. (This should never</span></span><br><span class="line">				<span class="comment">// happen on 32-bit.)</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// 2) We would need to discard too</span></span><br><span class="line">				<span class="comment">// much of our current arena block to</span></span><br><span class="line">				<span class="comment">// use it.</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// We haven&#x27;t added this allocation to</span></span><br><span class="line">				<span class="comment">// the stats, so subtract it from a</span></span><br><span class="line">				<span class="comment">// fake stat (but avoid underflow).</span></span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="comment">// We&#x27;ll fall back to a small sysAlloc.</span></span><br><span class="line">				stat := <span class="type">uint64</span>(p_size)</span><br><span class="line">				sysFree(unsafe.Pointer(p), p_size, &amp;stat)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预留的空间足够时只需要增加arena_alloc</span></span><br><span class="line">	<span class="keyword">if</span> n &lt;= h.arena_end-h.arena_alloc &#123;</span><br><span class="line">		<span class="comment">// Keep taking from our reservation.</span></span><br><span class="line">		p := h.arena_alloc</span><br><span class="line">		sysMap(unsafe.Pointer(p), n, h.arena_reserved, &amp;memstats.heap_sys)</span><br><span class="line">		h.arena_alloc += n</span><br><span class="line">		<span class="keyword">if</span> h.arena_alloc &gt; h.arena_used &#123;</span><br><span class="line">			h.setArenaUsed(h.arena_alloc, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> p&amp;(_PageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;misrounded allocation in MHeap_SysAlloc&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(p)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预留空间失败后的处理</span></span><br><span class="line">reservationFailed:</span><br><span class="line">	<span class="comment">// If using 64-bit, our reservation is all we have.</span></span><br><span class="line">	<span class="keyword">if</span> sys.PtrSize != <span class="number">4</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// On 32-bit, once the reservation is gone we can</span></span><br><span class="line">	<span class="comment">// try to get memory at a location chosen by the OS.</span></span><br><span class="line">	p_size := round(n, _PageSize) + _PageSize</span><br><span class="line">	p := <span class="type">uintptr</span>(sysAlloc(p_size, &amp;memstats.heap_sys))</span><br><span class="line">	<span class="keyword">if</span> p == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p &lt; h.arena_start || p+p_size-h.arena_start &gt; _MaxMem &#123;</span><br><span class="line">		<span class="comment">// This shouldn&#x27;t be possible because _MaxMem is the</span></span><br><span class="line">		<span class="comment">// whole address space on 32-bit.</span></span><br><span class="line">		top := <span class="type">uint64</span>(h.arena_start) + _MaxMem</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: memory allocated by OS (&quot;</span>, hex(p), <span class="string">&quot;) not in usable range [&quot;</span>, hex(h.arena_start), <span class="string">&quot;,&quot;</span>, hex(top), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		sysFree(unsafe.Pointer(p), p_size, &amp;memstats.heap_sys)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p += -p &amp; (_PageSize - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> p+n &gt; h.arena_used &#123;</span><br><span class="line">		h.setArenaUsed(p+n, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p&amp;(_PageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;misrounded allocation in MHeap_SysAlloc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是分配对象的完整流程了, 接下来分析GC标记和回收对象的处理.</p>
<h1 id="回收对象的处理"><a href="#回收对象的处理" class="headerlink" title="回收对象的处理"></a>回收对象的处理</h1><h3 id="回收对象的流程"><a href="#回收对象的流程" class="headerlink" title="回收对象的流程"></a>回收对象的流程</h3><p>GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.<br>首先GC有四个阶段, 它们分别是:</p>
<ul>
<li>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC</li>
<li>Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收</li>
<li>Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW)</li>
<li>Sweep: 按标记结果清扫span</li>
</ul>
<p>下图是比较完整的GC流程, 并按颜色对这四个阶段进行了分类:</p>
<p><img src="https://images2017.cnblogs.com/blog/881857/201711/881857-20171122165749274-1840348396.png" alt="img"></p>
<p>在GC过程中会有两种后台任务(G), 一种是标记用的后台任务, 一种是清扫用的后台任务.<br>标记用的后台任务会在需要时启动, 可以同时工作的后台任务数量大约是P的数量的25%, 也就是go所讲的让25%的cpu用在GC上的根据.<br>清扫用的后台任务在程序启动时会启动一个, 进入清扫阶段时唤醒.</p>
<p>目前整个GC流程会进行两次STW(Stop The World), 第一次是Mark阶段的开始, 第二次是Mark Termination阶段.<br>第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist).<br>第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist).<br>需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.<br>从go 1.9开始, 写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间.</p>
<h3 id="GC的触发条件"><a href="#GC的触发条件" class="headerlink" title="GC的触发条件"></a>GC的触发条件</h3><p>GC在满足一定条件后会被触发, 触发条件有以下几种:</p>
<ul>
<li>gcTriggerAlways: 强制触发GC</li>
<li>gcTriggerHeap: 当前分配的内存达到一定值就触发GC</li>
<li>gcTriggerTime: 当一定时间没有执行过GC就触发GC</li>
<li>gcTriggerCycle: 要求启动新一轮的GC, 已启动则跳过, 手动触发GC的<code>runtime.GC()</code>会使用这个条件</li>
</ul>
<p>触发条件的判断在gctrigger的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1154">test</a>函数.<br>其中gcTriggerHeap和gcTriggerTime这两个条件是自然触发的, gcTriggerHeap的判断代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br></pre></td></tr></table></figure>

<p>heap_live的增加在上面对分配器的代码分析中可以看到, 当值达到gc_trigger就会触发GC, 那么gc_trigger是如何决定的?<br>gc_trigger的计算在<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L759">gcSetTriggerRatio</a>函数中, 公式是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trigger = <span class="type">uint64</span>(<span class="type">float64</span>(memstats.heap_marked) * (<span class="number">1</span> + triggerRatio))</span><br></pre></td></tr></table></figure>

<p>当前标记存活的大小乘以1+系数triggerRatio, 就是下次出发GC需要的分配量.<br>triggerRatio在每次GC后都会调整, 计算triggerRatio的函数是<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L542">encCycle</a>, 公式是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> triggerGain = <span class="number">0.5</span></span><br><span class="line"><span class="comment">// 目标Heap增长率, 默认是1.0</span></span><br><span class="line">goalGrowthRatio := <span class="type">float64</span>(gcpercent) / <span class="number">100</span></span><br><span class="line"><span class="comment">// 实际Heap增长率, 等于总大小/存活大小-1</span></span><br><span class="line">actualGrowthRatio := <span class="type">float64</span>(memstats.heap_live)/<span class="type">float64</span>(memstats.heap_marked) - <span class="number">1</span></span><br><span class="line"><span class="comment">// GC标记阶段的使用时间(因为endCycle是在Mark Termination阶段调用的)</span></span><br><span class="line">assistDuration := nanotime() - c.markStartTime</span><br><span class="line"><span class="comment">// GC标记阶段的CPU占用率, 目标值是0.25</span></span><br><span class="line">utilization := gcGoalUtilization</span><br><span class="line"><span class="keyword">if</span> assistDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// assistTime是G辅助GC标记对象所使用的时间合计</span></span><br><span class="line">	<span class="comment">// (nanosecnds spent in mutator assists during this cycle)</span></span><br><span class="line">	<span class="comment">// 额外的CPU占用率 = 辅助GC标记对象的总时间 / (GC标记使用时间 * P的数量)</span></span><br><span class="line">	utilization += <span class="type">float64</span>(c.assistTime) / <span class="type">float64</span>(assistDuration*<span class="type">int64</span>(gomaxprocs))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发系数偏移值 = 目标增长率 - 原触发系数 - CPU占用率 / 目标CPU占用率 * (实际增长率 - 原触发系数)</span></span><br><span class="line"><span class="comment">// 参数的分析:</span></span><br><span class="line"><span class="comment">// 实际增长率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早</span></span><br><span class="line"><span class="comment">// CPU占用率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早</span></span><br><span class="line"><span class="comment">// 原触发系数越大, 触发系数偏移值越小, 小于0时下次触发GC会提早</span></span><br><span class="line">triggerError := goalGrowthRatio - memstats.triggerRatio - utilization/gcGoalUtilization*(actualGrowthRatio-memstats.triggerRatio)</span><br><span class="line"><span class="comment">// 根据偏移值调整触发系数, 每次只调整偏移值的一半(渐进式调整)</span></span><br><span class="line">triggerRatio := memstats.triggerRatio + triggerGain*triggerError</span><br></pre></td></tr></table></figure>

<p>公式中的”目标Heap增长率”可以通过设置环境变量”GOGC”调整, 默认值是100, 增加它的值可以减少GC的触发.<br>设置”GOGC&#x3D;off”可以彻底关掉GC.</p>
<p>gcTriggerTime的判断代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line"><span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br></pre></td></tr></table></figure>

<p>forcegcperiod的定义是2分钟, 也就是2分钟内没有执行过GC就会强制触发.</p>
<h3 id="三色的定义-黑-灰-白"><a href="#三色的定义-黑-灰-白" class="headerlink" title="三色的定义(黑, 灰, 白)"></a>三色的定义(黑, 灰, 白)</h3><p>我看过的对三色GC的”三色”这个概念解释的最好的文章就是<a target="_blank" rel="noopener" href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice">这一篇</a>了, 强烈建议先看这一篇中的讲解.<br>“三色”的概念可以简单的理解为:</p>
<ul>
<li>黑色: 对象在这次GC中已标记, 且这个对象包含的子对象也已标记</li>
<li>灰色: 对象在这次GC中已标记, 但这个对象包含的子对象未标记</li>
<li>白色: 对象在这次GC中未标记</li>
</ul>
<p>在go内部对象并没有保存颜色的属性, 三色只是对它们的状态的描述,<br>白色的对象在它所在的span的gcmarkBits中对应的bit为0,<br>灰色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象在标记队列中,<br>黑色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象已经从标记队列中取出并处理.<br>gc完成后, gcmarkBits会移动到allocBits然后重新分配一个全部为0的bitmap, 这样黑色的对象就变为了白色.</p>
<h3 id="写屏障-Write-Barrier"><a href="#写屏障-Write-Barrier" class="headerlink" title="写屏障(Write Barrier)"></a>写屏障(Write Barrier)</h3><p>因为go支持并行GC, GC的扫描和go代码可以同时运行, 这样带来的问题是GC扫描的过程中go代码有可能改变了对象的依赖树,<br>例如开始扫描时发现根对象A和B, B拥有C的指针, GC先扫描A, 然后B把C的指针交给A, GC再扫描B, 这时C就不会被扫描到.<br>为了避免这个问题, go在GC的标记阶段会启用写屏障(Write Barrier).</p>
<p>启用了写屏障(Write Barrier)后, 当B把C的指针交给A时, GC会认为在这一轮的扫描中C的指针是存活的,<br>即使A可能会在稍后丢掉C, 那么C就在下一轮回收.<br>写屏障只针对指针启用, 而且只在GC的标记阶段启用, 平时会直接把值写入到目标地址.</p>
<p>go在1.9开始启用了<a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">混合写屏障(Hybrid Write Barrier)</a>, 伪代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writePointer(slot, ptr):</span><br><span class="line">    shade(*slot)</span><br><span class="line">    <span class="keyword">if</span> any stack is grey:</span><br><span class="line">        shade(ptr)</span><br><span class="line">    *slot = ptr</span><br></pre></td></tr></table></figure>

<p>混合写屏障会同时标记指针写入目标的”原指针”和“新指针”.</p>
<p>标记原指针的原因是, 其他运行中的线程有可能会同时把这个指针的值复制到寄存器或者栈上的本地变量,<br>因为<strong>复制指针到寄存器或者栈上的本地变量不会经过写屏障</strong>, 所以有可能会导致指针不被标记, 试想下面的情况:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[go] b = obj</span><br><span class="line">[go] oldx = nil</span><br><span class="line">[gc] scan oldx...</span><br><span class="line">[go] oldx = b.x // 复制b.x到本地变量, 不进过写屏障</span><br><span class="line">[go] b.x = ptr // 写屏障应该标记b.x的原值</span><br><span class="line">[gc] scan b...</span><br><span class="line">如果写屏障不标记原值, 那么oldx就不会被扫描到.</span><br></pre></td></tr></table></figure>

<p>标记新指针的原因是, 其他运行中的线程有可能会转移指针的位置, 试想下面的情况:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[go] a = ptr</span><br><span class="line">[go] b = obj</span><br><span class="line">[gc] scan b...</span><br><span class="line">[go] b.x = a // 写屏障应该标记b.x的新值</span><br><span class="line">[go] a = nil</span><br><span class="line">[gc] scan a...</span><br><span class="line">如果写屏障不标记新值, 那么ptr就不会被扫描到.</span><br></pre></td></tr></table></figure>

<p>混合写屏障可以让GC在并行标记结束后不需要重新扫描各个G的堆栈, 可以减少Mark Termination中的STW时间.<br>除了写屏障外, 在GC的过程中所有新分配的对象都会立刻变为黑色, 在上面的mallocgc函数中可以看到.</p>
<h3 id="辅助GC-mutator-assist"><a href="#辅助GC-mutator-assist" class="headerlink" title="辅助GC(mutator assist)"></a>辅助GC(mutator assist)</h3><p>为了防止heap增速太快, 在GC执行的过程中如果同时运行的G分配了内存, 那么这个G会被要求辅助GC做一部分的工作.<br>在GC的过程中同时运行的G称为”mutator”, “mutator assist”机制就是G辅助GC做一部分工作的机制.</p>
<p>辅助GC做的工作有两种类型, 一种是标记(Mark), 另一种是清扫(Sweep).<br>辅助标记的触发可以查看上面的mallocgc函数, 触发时G会帮助扫描”工作量”个对象, 工作量的计算公式是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debtBytes * assistWorkPerByte</span><br></pre></td></tr></table></figure>

<p>意思是分配的大小乘以系数assistWorkPerByte, assistWorkPerByte的计算在函数<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L497">revise</a>中, 公式是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待扫描的对象数量 = 未扫描的对象数量 - 已扫描的对象数量</span></span><br><span class="line">scanWorkExpected := <span class="type">int64</span>(memstats.heap_scan) - c.scanWork</span><br><span class="line"><span class="keyword">if</span> scanWorkExpected &lt; <span class="number">1000</span> &#123;</span><br><span class="line">	scanWorkExpected = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 距离触发GC的Heap大小 = 期待触发GC的Heap大小 - 当前的Heap大小</span></span><br><span class="line"><span class="comment">// 注意next_gc的计算跟gc_trigger不一样, next_gc等于heap_marked * (1 + gcpercent / 100)</span></span><br><span class="line">heapDistance := <span class="type">int64</span>(memstats.next_gc) - <span class="type">int64</span>(atomic.Load64(&amp;memstats.heap_live))</span><br><span class="line"><span class="keyword">if</span> heapDistance &lt;= <span class="number">0</span> &#123;</span><br><span class="line">	heapDistance = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每分配1 byte需要辅助扫描的对象数量 = 等待扫描的对象数量 / 距离触发GC的Heap大小</span></span><br><span class="line">c.assistWorkPerByte = <span class="type">float64</span>(scanWorkExpected) / <span class="type">float64</span>(heapDistance)</span><br><span class="line">c.assistBytesPerWork = <span class="type">float64</span>(heapDistance) / <span class="type">float64</span>(scanWorkExpected)</span><br></pre></td></tr></table></figure>

<p>和辅助标记不一样的是, 辅助清扫申请新span时才会检查, 而辅助标记是每次分配对象时都会检查.<br>辅助清扫的触发可以看上面的cacheSpan函数, 触发时G会帮助回收”工作量”页的对象, 工作量的计算公式是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spanBytes * sweepPagesPerByte <span class="comment">// 不完全相同, 具体看deductSweepCredit函数</span></span><br></pre></td></tr></table></figure>

<p>意思是分配的大小乘以系数sweepPagesPerByte, sweepPagesPerByte的计算在函数<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L759">gcSetTriggerRatio</a>中, 公式是:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的Heap大小</span></span><br><span class="line">heapLiveBasis := atomic.Load64(&amp;memstats.heap_live)</span><br><span class="line"><span class="comment">// 距离触发GC的Heap大小 = 下次触发GC的Heap大小 - 当前的Heap大小</span></span><br><span class="line">heapDistance := <span class="type">int64</span>(trigger) - <span class="type">int64</span>(heapLiveBasis)</span><br><span class="line">heapDistance -= <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"><span class="keyword">if</span> heapDistance &lt; _PageSize &#123;</span><br><span class="line">	heapDistance = _PageSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已清扫的页数</span></span><br><span class="line">pagesSwept := atomic.Load64(&amp;mheap_.pagesSwept)</span><br><span class="line"><span class="comment">// 未清扫的页数 = 使用中的页数 - 已清扫的页数</span></span><br><span class="line">sweepDistancePages := <span class="type">int64</span>(mheap_.pagesInUse) - <span class="type">int64</span>(pagesSwept)</span><br><span class="line"><span class="keyword">if</span> sweepDistancePages &lt;= <span class="number">0</span> &#123;</span><br><span class="line">	mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 每分配1 byte(的span)需要辅助清扫的页数 = 未清扫的页数 / 距离触发GC的Heap大小</span></span><br><span class="line">	mheap_.sweepPagesPerByte = <span class="type">float64</span>(sweepDistancePages) / <span class="type">float64</span>(heapDistance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h3><p>在GC的标记阶段首先需要标记的就是”根对象”, 从根对象开始可到达的所有对象都会被认为是存活的.<br>根对象包含了全局变量, 各个G的栈上的变量等, GC会先扫描根对象然后再扫描根对象可到达的所有对象.<br>扫描根对象包含了一系列的工作, 它们定义在[<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54]%E5%87%BD%E6%95%B0">https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54]函数</a>:</p>
<ul>
<li>Fixed Roots: 特殊的扫描工作<ul>
<li>fixedRootFinalizers: 扫描析构器队列</li>
<li>fixedRootFreeGStacks: 释放已中止的G的栈</li>
</ul>
</li>
<li>Flush Cache Roots: 释放mcache中的所有span, 要求STW</li>
<li>Data Roots: 扫描可读写的全局变量</li>
<li>BSS Roots: 扫描只读的全局变量</li>
<li>Span Roots: 扫描各个span中特殊对象(析构器列表)</li>
<li>Stack Roots: 扫描各个G的栈</li>
</ul>
<p>标记阶段(Mark)会做其中的”Fixed Roots”, “Data Roots”, “BSS Roots”, “Span Roots”, “Stack Roots”.<br>完成标记阶段(Mark Termination)会做其中的”Fixed Roots”, “Flush Cache Roots”.</p>
<h3 id="标记队列"><a href="#标记队列" class="headerlink" title="标记队列"></a>标记队列</h3><p>GC的标记阶段会使用”标记队列”来确定所有可从根对象到达的对象都已标记, 上面提到的”灰色”的对象就是在标记队列中的对象.<br>举例来说, 如果当前有[A, B, C]这三个根对象, 那么扫描根对象时就会把它们放到标记队列:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [A, B, C]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列中取出A, 如果A引用了D, 则把D放入标记队列:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [B, C, D]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列取出B, 如果B也引用了D, 这时因为D在gcmarkBits中对应的bit已经是1所以会跳过:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [C, D]</span><br></pre></td></tr></table></figure>

<p>如果并行运行的go代码分配了一个对象E, 对象E会被立刻标记, 但不会进入标记队列(因为确定E没有引用其他对象).<br>然后并行运行的go代码把对象F设置给对象E的成员, 写屏障会标记对象F然后把对象F加到运行队列:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [C, D, F]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列取出C, 如果C没有引用其他对象, 则不需要处理:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [D, F]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列取出D, 如果D引用了X, 则把X放入标记队列:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work queue: [F, X]</span><br></pre></td></tr></table></figure>

<p>后台标记任务从标记队列取出F, 如果F没有引用其他对象, 则不需要处理.<br>后台标记任务从标记队列取出X, 如果X没有引用其他对象, 则不需要处理.<br>最后标记队列为空, 标记完成, 存活的对象有[A, B, C, D, E, F, X].</p>
<p>实际的状况会比上面介绍的状况稍微复杂一点.<br>标记队列会分为全局标记队列和各个P的本地标记队列, 这点和协程中的运行队列相似.<br>并且标记队列为空以后, 还需要停止整个世界并禁止写屏障, 然后再次检查是否为空.</p>
<h3 id="源代码分析-1"><a href="#源代码分析-1" class="headerlink" title="源代码分析"></a>源代码分析</h3><p>go触发gc会从<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1190">gcStart</a>函数开始:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcStart transitions the GC from _GCoff to _GCmark (if</span></span><br><span class="line"><span class="comment">// !mode.stwMark) or _GCmarktermination (if mode.stwMark) by</span></span><br><span class="line"><span class="comment">// performing sweep termination and GC initialization.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This may return without performing this transition in some cases,</span></span><br><span class="line"><span class="comment">// such as when called on a system stack or with locks held.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(mode gcMode, trigger gcTrigger)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断当前G是否可抢占, 不可抢占时不触发GC</span></span><br><span class="line">	<span class="comment">// Since this is called from malloc and malloc is called in</span></span><br><span class="line">	<span class="comment">// the guts of a number of libraries that might be holding</span></span><br><span class="line">	<span class="comment">// locks, don&#x27;t attempt to start GC in non-preemptible or</span></span><br><span class="line">	<span class="comment">// potentially unstable situations.</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	<span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		releasem(mp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	releasem(mp)</span><br><span class="line">	mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并行清扫上一轮GC未清扫的span</span></span><br><span class="line">	<span class="comment">// Pick up the remaining unswept/not being swept spans concurrently</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This shouldn&#x27;t happen if we&#x27;re being invoked in background</span></span><br><span class="line">	<span class="comment">// mode since proportional sweep should have just finished</span></span><br><span class="line">	<span class="comment">// sweeping everything, but rounding errors, etc, may leave a</span></span><br><span class="line">	<span class="comment">// few spans unswept. In forced mode, this is necessary since</span></span><br><span class="line">	<span class="comment">// GC can be forced at any point in the sweeping cycle.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// We check the transition condition continuously here in case</span></span><br><span class="line">	<span class="comment">// this G gets delayed in to the next GC cycle.</span></span><br><span class="line">	<span class="keyword">for</span> trigger.test() &amp;&amp; gosweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		sweep.nbgsweep++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上锁, 然后重新检查gcTrigger的条件是否成立, 不成立时不触发GC</span></span><br><span class="line">	<span class="comment">// Perform GC initialization and the sweep termination</span></span><br><span class="line">	<span class="comment">// transition.</span></span><br><span class="line">	semacquire(&amp;work.startSema)</span><br><span class="line">	<span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line">	<span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">		semrelease(&amp;work.startSema)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录是否强制触发, gcTriggerCycle是runtime.GC用的</span></span><br><span class="line">	<span class="comment">// For stats, check if this GC was forced by the user.</span></span><br><span class="line">	work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否指定了禁止并行GC的参数</span></span><br><span class="line">	<span class="comment">// In gcstoptheworld debug mode, upgrade the mode accordingly.</span></span><br><span class="line">	<span class="comment">// We do this after re-checking the transition condition so</span></span><br><span class="line">	<span class="comment">// that multiple goroutines that detect the heap trigger don&#x27;t</span></span><br><span class="line">	<span class="comment">// start multiple STW GCs.</span></span><br><span class="line">	<span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line">		<span class="keyword">if</span> debug.gcstoptheworld == <span class="number">1</span> &#123;</span><br><span class="line">			mode = gcForceMode</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">2</span> &#123;</span><br><span class="line">			mode = gcForceBlockMode</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ok, we&#x27;re doing it!  Stop everybody else</span></span><br><span class="line">	semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跟踪处理</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCStart()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动后台扫描任务(G)</span></span><br><span class="line">	<span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line">		gcBgMarkStartWorkers()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置标记相关的状态</span></span><br><span class="line">	gcResetMarkState()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置参数</span></span><br><span class="line">	work.stwprocs, work.maxprocs = gcprocs(), gomaxprocs</span><br><span class="line">	work.heap0 = atomic.Load64(&amp;memstats.heap_live)</span><br><span class="line">	work.pauseNS = <span class="number">0</span></span><br><span class="line">	work.mode = mode</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录开始时间</span></span><br><span class="line">	now := nanotime()</span><br><span class="line">	work.tSweepTerm = now</span><br><span class="line">	work.pauseStart = now</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 停止所有运行中的G, 并禁止它们运行</span></span><br><span class="line">	systemstack(stopTheWorldWithSema)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">	<span class="comment">// 世界已停止(STW)...</span></span><br><span class="line">	<span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 清扫上一轮GC未清扫的span, 确保上一轮GC已完成</span></span><br><span class="line">	<span class="comment">// Finish sweep before we start concurrent scan.</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		finishsweep_m()</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 清扫sched.sudogcache和sched.deferpool</span></span><br><span class="line">	<span class="comment">// clearpools before we start the GC. If we wait they memory will not be</span></span><br><span class="line">	<span class="comment">// reclaimed until the next GC cycle.</span></span><br><span class="line">	clearpools()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加GC计数</span></span><br><span class="line">	work.cycles++</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断是否并行GC模式</span></span><br><span class="line">	<span class="keyword">if</span> mode == gcBackgroundMode &#123; <span class="comment">// Do as much work concurrently as possible</span></span><br><span class="line">		<span class="comment">// 标记新一轮GC已开始</span></span><br><span class="line">		gcController.startCycle()</span><br><span class="line">		work.heapGoal = memstats.next_gc</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置全局变量中的GC状态为_GCmark</span></span><br><span class="line">		<span class="comment">// 然后启用写屏障</span></span><br><span class="line">		<span class="comment">// Enter concurrent mark phase and enable</span></span><br><span class="line">		<span class="comment">// write barriers.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Because the world is stopped, all Ps will</span></span><br><span class="line">		<span class="comment">// observe that write barriers are enabled by</span></span><br><span class="line">		<span class="comment">// the time we start the world and begin</span></span><br><span class="line">		<span class="comment">// scanning.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Write barriers must be enabled before assists are</span></span><br><span class="line">		<span class="comment">// enabled because they must be enabled before</span></span><br><span class="line">		<span class="comment">// any non-leaf heap objects are marked. Since</span></span><br><span class="line">		<span class="comment">// allocations are blocked until assists can</span></span><br><span class="line">		<span class="comment">// happen, we want enable assists as early as</span></span><br><span class="line">		<span class="comment">// possible.</span></span><br><span class="line">		setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重置后台标记任务的计数</span></span><br><span class="line">		gcBgMarkPrepare() <span class="comment">// Must happen before assist enable.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算扫描根对象的任务数量</span></span><br><span class="line">		gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 标记所有tiny alloc等待合并的对象</span></span><br><span class="line">		<span class="comment">// Mark all active tinyalloc blocks. Since we&#x27;re</span></span><br><span class="line">		<span class="comment">// allocating from these, they need to be black like</span></span><br><span class="line">		<span class="comment">// other allocations. The alternative is to blacken</span></span><br><span class="line">		<span class="comment">// the tiny block on every allocation from it, which</span></span><br><span class="line">		<span class="comment">// would slow down the tiny allocator.</span></span><br><span class="line">		gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 启用辅助GC</span></span><br><span class="line">		<span class="comment">// At this point all Ps have enabled the write</span></span><br><span class="line">		<span class="comment">// barrier, thus maintaining the no white to</span></span><br><span class="line">		<span class="comment">// black invariant. Enable mutator assists to</span></span><br><span class="line">		<span class="comment">// put back-pressure on fast allocating</span></span><br><span class="line">		<span class="comment">// mutators.</span></span><br><span class="line">		atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录标记开始的时间</span></span><br><span class="line">		<span class="comment">// Assists and workers can start the moment we start</span></span><br><span class="line">		<span class="comment">// the world.</span></span><br><span class="line">		gcController.markStartTime = now</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重新启动世界</span></span><br><span class="line">		<span class="comment">// 前面创建的后台标记任务会开始工作, 所有后台标记任务都完成工作后, 进入完成标记阶段</span></span><br><span class="line">		<span class="comment">// Concurrent mark.</span></span><br><span class="line">		systemstack(startTheWorldWithSema)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line">		<span class="comment">// 世界已重新启动...</span></span><br><span class="line">		<span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 记录停止了多久, 和标记阶段开始的时间</span></span><br><span class="line">		now = nanotime()</span><br><span class="line">		work.pauseNS += now - work.pauseStart</span><br><span class="line">		work.tMark = now</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 不是并行GC模式</span></span><br><span class="line">		<span class="comment">// 记录完成标记阶段开始的时间</span></span><br><span class="line">		t := nanotime()</span><br><span class="line">		work.tMark, work.tMarkTerm = t, t</span><br><span class="line">		work.heapGoal = work.heap0</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 跳过标记阶段, 执行完成标记阶段</span></span><br><span class="line">		<span class="comment">// 所有标记工作都会在世界已停止的状态执行</span></span><br><span class="line">		<span class="comment">// (标记阶段会设置work.markrootDone=true, 如果跳过则它的值是false, 完成标记阶段会执行所有工作)</span></span><br><span class="line">		<span class="comment">// 完成标记阶段会重新启动世界</span></span><br><span class="line">		<span class="comment">// Perform mark termination. This will restart the world.</span></span><br><span class="line">		gcMarkTermination(memstats.triggerRatio)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来一个个分析gcStart调用的函数, 建议配合上面的”回收对象的流程”中的图理解.</p>
<p>函数<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1650">gcBgMarkStartWorkers</a>用于启动后台标记任务, 先分别对每个P启动一个:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcBgMarkStartWorkers prepares background mark worker goroutines.</span></span><br><span class="line"><span class="comment">// These goroutines will not run until the mark phase, but they must</span></span><br><span class="line"><span class="comment">// be started while the work is not stopped and from a regular G</span></span><br><span class="line"><span class="comment">// stack. The caller must hold worldsema.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Background marking is performed by per-P G&#x27;s. Ensure that</span></span><br><span class="line">	<span class="comment">// each P has a background GC G.</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> &amp;allp &#123;</span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> || p.status == _Pdead &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果已启动则不重复启动</span></span><br><span class="line">		<span class="keyword">if</span> p.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> gcBgMarkWorker(p)</span><br><span class="line">			<span class="comment">// 启动后等待该任务通知信号量bgMarkReady再继续</span></span><br><span class="line">			notetsleepg(&amp;work.bgMarkReady, <span class="number">-1</span>)</span><br><span class="line">			noteclear(&amp;work.bgMarkReady)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里虽然为每个P启动了一个后台标记任务, 但是可以同时工作的只有25%, 这个逻辑在协程M获取G时调用的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L657">findRunnableGCWorker</a>中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findRunnableGCWorker returns the background mark worker for _p_ if it</span></span><br><span class="line"><span class="comment">// should be run. This must only be called when gcBlackenEnabled != 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> findRunnableGCWorker(_p_ *p) *g &#123;</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;gcControllerState.findRunnable: blackening not enabled&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The mark worker associated with this P is blocked</span></span><br><span class="line">		<span class="comment">// performing a mark transition. We can&#x27;t run it</span></span><br><span class="line">		<span class="comment">// because it may be on some other run or wait queue.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		<span class="comment">// No work to be done right now. This can happen at</span></span><br><span class="line">		<span class="comment">// the end of the mark phase when there are still</span></span><br><span class="line">		<span class="comment">// assists tapering off. Don&#x27;t bother running a worker</span></span><br><span class="line">		<span class="comment">// now because it&#x27;ll just return immediately.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 原子减少对应的值, 如果减少后大于等于0则返回true, 否则返回false</span></span><br><span class="line">	decIfPositive := <span class="function"><span class="keyword">func</span><span class="params">(ptr *<span class="type">int64</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> *ptr &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> atomic.Xaddint64(ptr, <span class="number">-1</span>) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// We lost a race</span></span><br><span class="line">			atomic.Xaddint64(ptr, +<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 减少dedicatedMarkWorkersNeeded, 成功时后台标记任务的模式是Dedicated</span></span><br><span class="line">	<span class="comment">// dedicatedMarkWorkersNeeded是当前P的数量的25%去除小数点</span></span><br><span class="line">	<span class="comment">// 详见startCycle函数</span></span><br><span class="line">	<span class="keyword">if</span> decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) &#123;</span><br><span class="line">		<span class="comment">// This P is now dedicated to marking until the end of</span></span><br><span class="line">		<span class="comment">// the concurrent mark phase.</span></span><br><span class="line">		_p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 减少fractionalMarkWorkersNeeded, 成功是后台标记任务的模式是Fractional</span></span><br><span class="line">		<span class="comment">// 上面的计算如果小数点后有数值(不能够整除)则fractionalMarkWorkersNeeded为1, 否则为0</span></span><br><span class="line">		<span class="comment">// 详见startCycle函数</span></span><br><span class="line">		<span class="comment">// 举例来说, 4个P时会执行1个Dedicated模式的任务, 5个P时会执行1个Dedicated模式和1个Fractional模式的任务</span></span><br><span class="line">		<span class="keyword">if</span> !decIfPositive(&amp;c.fractionalMarkWorkersNeeded) &#123;</span><br><span class="line">			<span class="comment">// No more workers are need right now.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 按Dedicated模式的任务的执行时间判断cpu占用率是否超过预算值, 超过时不启动</span></span><br><span class="line">		<span class="comment">// This P has picked the token for the fractional worker.</span></span><br><span class="line">		<span class="comment">// Is the GC currently under or at the utilization goal?</span></span><br><span class="line">		<span class="comment">// If so, do more work.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// We used to check whether doing one time slice of work</span></span><br><span class="line">		<span class="comment">// would remain under the utilization goal, but that has the</span></span><br><span class="line">		<span class="comment">// effect of delaying work until the mutator has run for</span></span><br><span class="line">		<span class="comment">// enough time slices to pay for the work. During those time</span></span><br><span class="line">		<span class="comment">// slices, write barriers are enabled, so the mutator is running slower.</span></span><br><span class="line">		<span class="comment">// Now instead we do the work whenever we&#x27;re under or at the</span></span><br><span class="line">		<span class="comment">// utilization work and pay for it by letting the mutator run later.</span></span><br><span class="line">		<span class="comment">// This doesn&#x27;t change the overall utilization averages, but it</span></span><br><span class="line">		<span class="comment">// front loads the GC work so that the GC finishes earlier and</span></span><br><span class="line">		<span class="comment">// write barriers can be turned off sooner, effectively giving</span></span><br><span class="line">		<span class="comment">// the mutator a faster machine.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// The old, slower behavior can be restored by setting</span></span><br><span class="line">		<span class="comment">//	gcForcePreemptNS = forcePreemptNS.</span></span><br><span class="line">		<span class="keyword">const</span> gcForcePreemptNS = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// TODO(austin): We could fast path this and basically</span></span><br><span class="line">		<span class="comment">// eliminate contention on c.fractionalMarkWorkersNeeded by</span></span><br><span class="line">		<span class="comment">// precomputing the minimum time at which it&#x27;s worth</span></span><br><span class="line">		<span class="comment">// next scheduling the fractional worker. Then Ps</span></span><br><span class="line">		<span class="comment">// don&#x27;t have to fight in the window where we&#x27;ve</span></span><br><span class="line">		<span class="comment">// passed that deadline and no one has started the</span></span><br><span class="line">		<span class="comment">// worker yet.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// TODO(austin): Shorter preemption interval for mark</span></span><br><span class="line">		<span class="comment">// worker to improve fairness and give this</span></span><br><span class="line">		<span class="comment">// finer-grained control over schedule?</span></span><br><span class="line">		now := nanotime() - gcController.markStartTime</span><br><span class="line">		then := now + gcForcePreemptNS</span><br><span class="line">		timeUsed := c.fractionalMarkTime + gcForcePreemptNS</span><br><span class="line">		<span class="keyword">if</span> then &gt; <span class="number">0</span> &amp;&amp; <span class="type">float64</span>(timeUsed)/<span class="type">float64</span>(then) &gt; c.fractionalUtilizationGoal &#123;</span><br><span class="line">			<span class="comment">// Nope, we&#x27;d overshoot the utilization goal</span></span><br><span class="line">			atomic.Xaddint64(&amp;c.fractionalMarkWorkersNeeded, +<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		_p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 安排后台标记任务执行</span></span><br><span class="line">	<span class="comment">// Run the background mark worker</span></span><br><span class="line">	gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">	casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L2040">gcResetMarkState</a>函数会重置标记相关的状态:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcResetMarkState resets global state prior to marking (concurrent</span></span><br><span class="line"><span class="comment">// or STW) and resets the stack scan state of all Gs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is safe to do without the world stopped because any Gs created</span></span><br><span class="line"><span class="comment">// during or after this will start out in the reset state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcResetMarkState</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// This may be called during a concurrent phase, so make sure</span></span><br><span class="line">	<span class="comment">// allgs doesn&#x27;t change.</span></span><br><span class="line">	lock(&amp;allglock)</span><br><span class="line">	<span class="keyword">for</span> _, gp := <span class="keyword">range</span> allgs &#123;</span><br><span class="line">		gp.gcscandone = <span class="literal">false</span>  <span class="comment">// set to true in gcphasework</span></span><br><span class="line">		gp.gcscanvalid = <span class="literal">false</span> <span class="comment">// stack has not been scanned</span></span><br><span class="line">		gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;allglock)</span><br><span class="line"></span><br><span class="line">	work.bytesMarked = <span class="number">0</span></span><br><span class="line">	work.initialHeapLive = atomic.Load64(&amp;memstats.heap_live)</span><br><span class="line">	work.markrootDone = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L987">stopTheWorldWithSema</a>函数会停止整个世界, 这个函数必须在g0中运行:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stopTheWorldWithSema is the core implementation of stopTheWorld.</span></span><br><span class="line"><span class="comment">// The caller is responsible for acquiring worldsema and disabling</span></span><br><span class="line"><span class="comment">// preemption first and then should stopTheWorldWithSema on the system</span></span><br><span class="line"><span class="comment">// stack:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	semacquire(&amp;worldsema, 0)</span></span><br><span class="line"><span class="comment">//	m.preemptoff = &quot;reason&quot;</span></span><br><span class="line"><span class="comment">//	systemstack(stopTheWorldWithSema)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When finished, the caller must either call startTheWorld or undo</span></span><br><span class="line"><span class="comment">// these three operations separately:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	m.preemptoff = &quot;&quot;</span></span><br><span class="line"><span class="comment">//	systemstack(startTheWorldWithSema)</span></span><br><span class="line"><span class="comment">//	semrelease(&amp;worldsema)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is allowed to acquire worldsema once and then execute multiple</span></span><br><span class="line"><span class="comment">// startTheWorldWithSema/stopTheWorldWithSema pairs.</span></span><br><span class="line"><span class="comment">// Other P&#x27;s are able to execute between successive calls to</span></span><br><span class="line"><span class="comment">// startTheWorldWithSema and stopTheWorldWithSema.</span></span><br><span class="line"><span class="comment">// Holding worldsema causes any other goroutines invoking</span></span><br><span class="line"><span class="comment">// stopTheWorld to block.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we hold a lock, then we won&#x27;t be able to stop another M</span></span><br><span class="line">	<span class="comment">// that is blocked trying to acquire the lock.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;stopTheWorld: holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 需要停止的P数量</span></span><br><span class="line">	sched.stopwait = gomaxprocs</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置gc等待标记, 调度时看见此标记会进入等待</span></span><br><span class="line">	atomic.Store(&amp;sched.gcwaiting, <span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 抢占所有运行中的G</span></span><br><span class="line">	preemptall()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 停止当前的P</span></span><br><span class="line">	<span class="comment">// stop current P</span></span><br><span class="line">	_g_.m.p.ptr().status = _Pgcstop <span class="comment">// Pgcstop is only diagnostic.</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 减少需要停止的P数量(当前的P算一个)</span></span><br><span class="line">	sched.stopwait--</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 抢占所有在Psyscall状态的P, 防止它们重新参与调度</span></span><br><span class="line">	<span class="comment">// try to retake all P&#x27;s in Psyscall status</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(gomaxprocs); i++ &#123;</span><br><span class="line">		p := allp[i]</span><br><span class="line">		s := p.status</span><br><span class="line">		<span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoSysBlock(p)</span><br><span class="line">				traceProcStop(p)</span><br><span class="line">			&#125;</span><br><span class="line">			p.syscalltick++</span><br><span class="line">			sched.stopwait--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 防止所有空闲的P重新参与调度</span></span><br><span class="line">	<span class="comment">// stop idle P&#x27;s</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := pidleget()</span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.status = _Pgcstop</span><br><span class="line">		sched.stopwait--</span><br><span class="line">	&#125;</span><br><span class="line">	wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果仍有需要停止的P, 则等待它们停止</span></span><br><span class="line">	<span class="comment">// wait for remaining P&#x27;s to stop voluntarily</span></span><br><span class="line">	<span class="keyword">if</span> wait &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 循环等待 + 抢占所有运行中的G</span></span><br><span class="line">			<span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">			<span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">				noteclear(&amp;sched.stopnote)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			preemptall()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 逻辑正确性检查</span></span><br><span class="line">	<span class="comment">// sanity checks</span></span><br><span class="line">	bad := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> sched.stopwait != <span class="number">0</span> &#123;</span><br><span class="line">		bad = <span class="string">&quot;stopTheWorld: not stopped (stopwait != 0)&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(gomaxprocs); i++ &#123;</span><br><span class="line">			p := allp[i]</span><br><span class="line">			<span class="keyword">if</span> p.status != _Pgcstop &#123;</span><br><span class="line">				bad = <span class="string">&quot;stopTheWorld: not stopped (status != _Pgcstop)&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;freezing) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Some other thread is panicking. This can cause the</span></span><br><span class="line">		<span class="comment">// sanity checks above to fail if the panic happens in</span></span><br><span class="line">		<span class="comment">// the signal handler on a stopped thread. Either way,</span></span><br><span class="line">		<span class="comment">// we should halt this thread.</span></span><br><span class="line">		lock(&amp;deadlock)</span><br><span class="line">		lock(&amp;deadlock)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> bad != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		throw(bad)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 到这里所有运行中的G都会变为待运行, 并且所有的P都不能被M获取</span></span><br><span class="line">	<span class="comment">// 也就是说所有的go代码(除了当前的)都会停止运行, 并且不能运行新的go代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L33">finishsweep_m</a>函数会清扫上一轮GC未清扫的span, 确保上一轮GC已完成:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// finishsweep_m ensures that all spans are swept.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The world must be stopped. This ensures there are no sweeps in</span></span><br><span class="line"><span class="comment">// progress.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finishsweep_m</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// sweepone会取出一个未sweep的span然后执行sweep</span></span><br><span class="line">	<span class="comment">// 详细将在下面sweep阶段时分析</span></span><br><span class="line">	<span class="comment">// Sweeping must be complete before marking commences, so</span></span><br><span class="line">	<span class="comment">// sweep any unswept spans. If this is a concurrent GC, there</span></span><br><span class="line">	<span class="comment">// shouldn&#x27;t be any spans left to sweep, so this should finish</span></span><br><span class="line">	<span class="comment">// instantly. If GC was forced before the concurrent sweep</span></span><br><span class="line">	<span class="comment">// finished, there may be spans to sweep.</span></span><br><span class="line">	<span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		sweep.npausesweep++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有span都sweep完成后, 启动一个新的markbit时代</span></span><br><span class="line">	<span class="comment">// 这个函数是实现span的gcmarkBits和allocBits的分配和复用的关键, 流程如下</span></span><br><span class="line">	<span class="comment">// - span分配gcmarkBits和allocBits</span></span><br><span class="line">	<span class="comment">// - span完成sweep</span></span><br><span class="line">	<span class="comment">//   - 原allocBits不再被使用</span></span><br><span class="line">	<span class="comment">//   - gcmarkBits变为allocBits</span></span><br><span class="line">	<span class="comment">//   - 分配新的gcmarkBits</span></span><br><span class="line">	<span class="comment">// - 开启新的markbit时代</span></span><br><span class="line">	<span class="comment">// - span完成sweep, 同上</span></span><br><span class="line">	<span class="comment">// - 开启新的markbit时代</span></span><br><span class="line">	<span class="comment">//   - 2个时代之前的bitmap将不再被使用, 可以复用这些bitmap</span></span><br><span class="line">	nextMarkBitArenaEpoch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L2065">clearpools</a>函数会清理sched.sudogcache和sched.deferpool, 让它们的内存可以被回收:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clearpools</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// clear sync.Pools</span></span><br><span class="line">	<span class="keyword">if</span> poolcleanup != <span class="literal">nil</span> &#123;</span><br><span class="line">		poolcleanup()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear central sudog cache.</span></span><br><span class="line">	<span class="comment">// Leave per-P caches alone, they have strictly bounded size.</span></span><br><span class="line">	<span class="comment">// Disconnect cached list before dropping it on the floor,</span></span><br><span class="line">	<span class="comment">// so that a dangling ref to one entry does not pin all of them.</span></span><br><span class="line">	lock(&amp;sched.sudoglock)</span><br><span class="line">	<span class="keyword">var</span> sg, sgnext *sudog</span><br><span class="line">	<span class="keyword">for</span> sg = sched.sudogcache; sg != <span class="literal">nil</span>; sg = sgnext &#123;</span><br><span class="line">		sgnext = sg.next</span><br><span class="line">		sg.next = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	sched.sudogcache = <span class="literal">nil</span></span><br><span class="line">	unlock(&amp;sched.sudoglock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear central defer pools.</span></span><br><span class="line">	<span class="comment">// Leave per-P pools alone, they have strictly bounded size.</span></span><br><span class="line">	lock(&amp;sched.deferlock)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> sched.deferpool &#123;</span><br><span class="line">		<span class="comment">// disconnect cached list before dropping it on the floor,</span></span><br><span class="line">		<span class="comment">// so that a dangling ref to one entry does not pin all of them.</span></span><br><span class="line">		<span class="keyword">var</span> d, dlink *_defer</span><br><span class="line">		<span class="keyword">for</span> d = sched.deferpool[i]; d != <span class="literal">nil</span>; d = dlink &#123;</span><br><span class="line">			dlink = d.link</span><br><span class="line">			d.link = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		sched.deferpool[i] = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.deferlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L420">startCycle</a>标记开始了新一轮的GC:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startCycle resets the GC controller&#x27;s state and computes estimates</span></span><br><span class="line"><span class="comment">// for a new GC cycle. The caller must hold worldsema.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> startCycle() &#123;</span><br><span class="line">	c.scanWork = <span class="number">0</span></span><br><span class="line">	c.bgScanCredit = <span class="number">0</span></span><br><span class="line">	c.assistTime = <span class="number">0</span></span><br><span class="line">	c.dedicatedMarkTime = <span class="number">0</span></span><br><span class="line">	c.fractionalMarkTime = <span class="number">0</span></span><br><span class="line">	c.idleMarkTime = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 伪装heap_marked的值如果gc_trigger的值很小, 防止后面对triggerRatio做出错误的调整</span></span><br><span class="line">	<span class="comment">// If this is the first GC cycle or we&#x27;re operating on a very</span></span><br><span class="line">	<span class="comment">// small heap, fake heap_marked so it looks like gc_trigger is</span></span><br><span class="line">	<span class="comment">// the appropriate growth from heap_marked, even though the</span></span><br><span class="line">	<span class="comment">// real heap_marked may not have a meaningful value (on the</span></span><br><span class="line">	<span class="comment">// first cycle) or may be much smaller (resulting in a large</span></span><br><span class="line">	<span class="comment">// error response).</span></span><br><span class="line">	<span class="keyword">if</span> memstats.gc_trigger &lt;= heapminimum &#123;</span><br><span class="line">		memstats.heap_marked = <span class="type">uint64</span>(<span class="type">float64</span>(memstats.gc_trigger) / (<span class="number">1</span> + memstats.triggerRatio))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新计算next_gc, 注意next_gc的计算跟gc_trigger不一样</span></span><br><span class="line">	<span class="comment">// Re-compute the heap goal for this cycle in case something</span></span><br><span class="line">	<span class="comment">// changed. This is the same calculation we use elsewhere.</span></span><br><span class="line">	memstats.next_gc = memstats.heap_marked + memstats.heap_marked*<span class="type">uint64</span>(gcpercent)/<span class="number">100</span></span><br><span class="line">	<span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">		memstats.next_gc = ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保next_gc和heap_live之间最少有1MB</span></span><br><span class="line">	<span class="comment">// Ensure that the heap goal is at least a little larger than</span></span><br><span class="line">	<span class="comment">// the current live heap size. This may not be the case if GC</span></span><br><span class="line">	<span class="comment">// start is delayed or if the allocation that pushed heap_live</span></span><br><span class="line">	<span class="comment">// over gc_trigger is large or if the trigger is really close to</span></span><br><span class="line">	<span class="comment">// GOGC. Assist is proportional to this distance, so enforce a</span></span><br><span class="line">	<span class="comment">// minimum distance, even if it means going over the GOGC goal</span></span><br><span class="line">	<span class="comment">// by a tiny bit.</span></span><br><span class="line">	<span class="keyword">if</span> memstats.next_gc &lt; memstats.heap_live+<span class="number">1024</span>*<span class="number">1024</span> &#123;</span><br><span class="line">		memstats.next_gc = memstats.heap_live + <span class="number">1024</span>*<span class="number">1024</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算可以同时执行的后台标记任务的数量</span></span><br><span class="line">	<span class="comment">// dedicatedMarkWorkersNeeded等于P的数量的25%去除小数点</span></span><br><span class="line">	<span class="comment">// 如果可以整除则fractionalMarkWorkersNeeded等于0否则等于1</span></span><br><span class="line">	<span class="comment">// totalUtilizationGoal是GC所占的P的目标值(例如P一共有5个时目标是1.25个P)</span></span><br><span class="line">	<span class="comment">// fractionalUtilizationGoal是Fractiona模式的任务所占的P的目标值(例如P一共有5个时目标是0.25个P)</span></span><br><span class="line">	<span class="comment">// Compute the total mark utilization goal and divide it among</span></span><br><span class="line">	<span class="comment">// dedicated and fractional workers.</span></span><br><span class="line">	totalUtilizationGoal := <span class="type">float64</span>(gomaxprocs) * gcGoalUtilization</span><br><span class="line">	c.dedicatedMarkWorkersNeeded = <span class="type">int64</span>(totalUtilizationGoal)</span><br><span class="line">	c.fractionalUtilizationGoal = totalUtilizationGoal - <span class="type">float64</span>(c.dedicatedMarkWorkersNeeded)</span><br><span class="line">	<span class="keyword">if</span> c.fractionalUtilizationGoal &gt; <span class="number">0</span> &#123;</span><br><span class="line">		c.fractionalMarkWorkersNeeded = <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.fractionalMarkWorkersNeeded = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置P中的辅助GC所用的时间统计</span></span><br><span class="line">	<span class="comment">// Clear per-P state</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> &amp;allp &#123;</span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.gcAssistTime = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算辅助GC的参数</span></span><br><span class="line">	<span class="comment">// 参考上面对计算assistWorkPerByte的公式的分析</span></span><br><span class="line">	<span class="comment">// Compute initial values for controls that are updated</span></span><br><span class="line">	<span class="comment">// throughout the cycle.</span></span><br><span class="line">	c.revise()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.gcpacertrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;pacer: assist ratio=&quot;</span>, c.assistWorkPerByte,</span><br><span class="line">			<span class="string">&quot; (scan &quot;</span>, memstats.heap_scan&gt;&gt;<span class="number">20</span>, <span class="string">&quot; MB in &quot;</span>,</span><br><span class="line">			work.initialHeapLive&gt;&gt;<span class="number">20</span>, <span class="string">&quot;-&gt;&quot;</span>,</span><br><span class="line">			memstats.next_gc&gt;&gt;<span class="number">20</span>, <span class="string">&quot; MB)&quot;</span>,</span><br><span class="line">			<span class="string">&quot; workers=&quot;</span>, c.dedicatedMarkWorkersNeeded,</span><br><span class="line">			<span class="string">&quot;+&quot;</span>, c.fractionalMarkWorkersNeeded, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L279">setGCPhase</a>函数会修改表示当前GC阶段的全局变量和<strong>是否开启写屏障</strong>的全局变量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setGCPhase</span><span class="params">(x <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	atomic.Store(&amp;gcphase, x)</span><br><span class="line">	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination</span><br><span class="line">	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1667">gcBgMarkPrepare</a>函数会重置后台标记任务的计数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcBgMarkPrepare sets up state for background marking.</span></span><br><span class="line"><span class="comment">// Mutator assists must not yet be enabled.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkPrepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Background marking will stop when the work queues are empty</span></span><br><span class="line">	<span class="comment">// and there are no more workers (note that, since this is</span></span><br><span class="line">	<span class="comment">// concurrent, this may be a transient state, but mark</span></span><br><span class="line">	<span class="comment">// termination will clean it up). Between background workers</span></span><br><span class="line">	<span class="comment">// and assists, we don&#x27;t really know how many workers there</span></span><br><span class="line">	<span class="comment">// will be, so we pretend to have an arbitrarily large number</span></span><br><span class="line">	<span class="comment">// of workers, almost all of which are &quot;waiting&quot;. While a</span></span><br><span class="line">	<span class="comment">// worker is working it decrements nwait. If nproc == nwait,</span></span><br><span class="line">	<span class="comment">// there are no workers.</span></span><br><span class="line">	work.nproc = ^<span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	work.nwait = ^<span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54">gcMarkRootPrepare</a>函数会计算扫描根对象的任务数量:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">// gcMarkRootPrepare queues root scanning jobs (stacks, globals, and</span><br><span class="line">// some miscellany) and initializes scanning-related state.</span><br><span class="line">//</span><br><span class="line">// The caller must have call gcCopySpans().</span><br><span class="line">//</span><br><span class="line">// The world must be stopped.</span><br><span class="line">//</span><br><span class="line">//go:nowritebarrier</span><br><span class="line">func gcMarkRootPrepare() &#123;</span><br><span class="line">	// 释放mcache中的所有span的任务, 只在完成标记阶段(mark termination)中执行</span><br><span class="line">	if gcphase == _GCmarktermination &#123;</span><br><span class="line">		work.nFlushCacheRoots = int(gomaxprocs)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		work.nFlushCacheRoots = 0</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 计算block数量的函数, rootBlockBytes是256KB</span><br><span class="line">	// Compute how many data and BSS root blocks there are.</span><br><span class="line">	nBlocks := func(bytes uintptr) int &#123;</span><br><span class="line">		return int((bytes + rootBlockBytes - 1) / rootBlockBytes)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	work.nDataRoots = 0</span><br><span class="line">	work.nBSSRoots = 0</span><br><span class="line"></span><br><span class="line">	// data和bss每一轮GC只扫描一次</span><br><span class="line">	// 并行GC中会在后台标记任务中扫描, 完成标记阶段(mark termination)中不扫描</span><br><span class="line">	// 非并行GC会在完成标记阶段(mark termination)中扫描</span><br><span class="line">	// Only scan globals once per cycle; preferably concurrently.</span><br><span class="line">	if !work.markrootDone &#123;</span><br><span class="line">		// 计算扫描可读写的全局变量的任务数量</span><br><span class="line">		for _, datap := range activeModules() &#123;</span><br><span class="line">			nDataRoots := nBlocks(datap.edata - datap.data)</span><br><span class="line">			if nDataRoots &gt; work.nDataRoots &#123;</span><br><span class="line">				work.nDataRoots = nDataRoots</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 计算扫描只读的全局变量的任务数量</span><br><span class="line">		for _, datap := range activeModules() &#123;</span><br><span class="line">			nBSSRoots := nBlocks(datap.ebss - datap.bss)</span><br><span class="line">			if nBSSRoots &gt; work.nBSSRoots &#123;</span><br><span class="line">				work.nBSSRoots = nBSSRoots</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// span中的finalizer和各个G的栈每一轮GC只扫描一次</span><br><span class="line">	// 同上</span><br><span class="line">	if !work.markrootDone &#123;</span><br><span class="line">		// 计算扫描span中的finalizer的任务数量</span><br><span class="line">		// On the first markroot, we need to scan span roots.</span><br><span class="line">		// In concurrent GC, this happens during concurrent</span><br><span class="line">		// mark and we depend on addfinalizer to ensure the</span><br><span class="line">		// above invariants for objects that get finalizers</span><br><span class="line">		// after concurrent mark. In STW GC, this will happen</span><br><span class="line">		// during mark termination.</span><br><span class="line">		//</span><br><span class="line">		// We&#x27;re only interested in scanning the in-use spans,</span><br><span class="line">		// which will all be swept at this point. More spans</span><br><span class="line">		// may be added to this list during concurrent GC, but</span><br><span class="line">		// we only care about spans that were allocated before</span><br><span class="line">		// this mark phase.</span><br><span class="line">		work.nSpanRoots = mheap_.sweepSpans[mheap_.sweepgen/2%2].numBlocks()</span><br><span class="line"></span><br><span class="line">		// 计算扫描各个G的栈的任务数量</span><br><span class="line">		// On the first markroot, we need to scan all Gs. Gs</span><br><span class="line">		// may be created after this point, but it&#x27;s okay that</span><br><span class="line">		// we ignore them because they begin life without any</span><br><span class="line">		// roots, so there&#x27;s nothing to scan, and any roots</span><br><span class="line">		// they create during the concurrent phase will be</span><br><span class="line">		// scanned during mark termination. During mark</span><br><span class="line">		// termination, allglen isn&#x27;t changing, so we&#x27;ll scan</span><br><span class="line">		// all Gs.</span><br><span class="line">		work.nStackRoots = int(atomic.Loaduintptr(&amp;allglen))</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// We&#x27;ve already scanned span roots and kept the scan</span><br><span class="line">		// up-to-date during concurrent mark.</span><br><span class="line">		work.nSpanRoots = 0</span><br><span class="line"></span><br><span class="line">		// The hybrid barrier ensures that stacks can&#x27;t</span><br><span class="line">		// contain pointers to unmarked objects, so on the</span><br><span class="line">		// second markroot, there&#x27;s no need to scan stacks.</span><br><span class="line">		work.nStackRoots = 0</span><br><span class="line"></span><br><span class="line">		if debug.gcrescanstacks &gt; 0 &#123;</span><br><span class="line">			// Scan stacks anyway for debugging.</span><br><span class="line">			work.nStackRoots = int(atomic.Loaduintptr(&amp;allglen))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 计算总任务数量</span><br><span class="line">	// 后台标记任务会对markrootNext进行原子递增, 来决定做哪个任务</span><br><span class="line">	// 这种用数值来实现锁自由队列的办法挺聪明的, 尽管google工程师觉得不好(看后面markroot函数的分析)</span><br><span class="line">	work.markrootNext = 0</span><br><span class="line">	work.markrootJobs = uint32(fixedRootCount + work.nFlushCacheRoots + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1358">gcMarkTinyAllocs</a>函数会标记所有tiny alloc等待合并的对象:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcMarkTinyAllocs greys all active tiny alloc blocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The world must be stopped.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTinyAllocs</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> &amp;allp &#123;</span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> || p.status == _Pdead &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		c := p.mcache</span><br><span class="line">		<span class="keyword">if</span> c == <span class="literal">nil</span> || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 标记各个P中的mcache中的tiny</span></span><br><span class="line">		<span class="comment">// 在上面的mallocgc函数中可以看到tiny是当前等待合并的对象</span></span><br><span class="line">		_, hbits, span, objIndex := heapBitsForObject(c.tiny, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">		gcw := &amp;p.gcw</span><br><span class="line">		<span class="comment">// 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)</span></span><br><span class="line">		greyobject(c.tiny, <span class="number">0</span>, <span class="number">0</span>, hbits, span, gcw, objIndex)</span><br><span class="line">		<span class="comment">// gcBlackenPromptly变量表示当前是否禁止本地队列, 如果已禁止则把标记任务flush到全局队列</span></span><br><span class="line">		<span class="keyword">if</span> gcBlackenPromptly &#123;</span><br><span class="line">			gcw.dispose()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1070">startTheWorldWithSema</a>函数会重新启动世界:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldWithSema</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 禁止G被抢占</span></span><br><span class="line">	_g_.m.locks++        <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断收到的网络事件(fd可读可写或错误)并添加对应的G到待运行队列</span></span><br><span class="line">	gp := netpoll(<span class="literal">false</span>) <span class="comment">// non-blocking</span></span><br><span class="line">	injectglist(gp)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断是否要启动gc helper</span></span><br><span class="line">	add := needaddgcproc()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果要求改变gomaxprocs则调整P的数量</span></span><br><span class="line">	<span class="comment">// procresize会返回有可运行任务的P的链表</span></span><br><span class="line">	procs := gomaxprocs</span><br><span class="line">	<span class="keyword">if</span> newprocs != <span class="number">0</span> &#123;</span><br><span class="line">		procs = newprocs</span><br><span class="line">		newprocs = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	p1 := procresize(procs)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 取消GC等待标记</span></span><br><span class="line">	sched.gcwaiting = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果sysmon在等待则唤醒它</span></span><br><span class="line">	<span class="keyword">if</span> sched.sysmonwait != <span class="number">0</span> &#123;</span><br><span class="line">		sched.sysmonwait = <span class="number">0</span></span><br><span class="line">		notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 唤醒有可运行任务的P</span></span><br><span class="line">	<span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		p := p1</span><br><span class="line">		p1 = p1.link.ptr()</span><br><span class="line">		<span class="keyword">if</span> p.m != <span class="number">0</span> &#123;</span><br><span class="line">			mp := p.m.ptr()</span><br><span class="line">			p.m = <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;startTheWorld: inconsistent mp-&gt;nextp&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			mp.nextp.set(p)</span><br><span class="line">			notewakeup(&amp;mp.park)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Start M to run P.  Do not start another M below.</span></span><br><span class="line">			newm(<span class="literal">nil</span>, p)</span><br><span class="line">			add = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果有空闲的P，并且没有自旋中的M则唤醒或者创建一个M</span></span><br><span class="line">	<span class="comment">// Wakeup an additional proc in case we have excessive runnable goroutines</span></span><br><span class="line">	<span class="comment">// in local queues or in the global queue. If we don&#x27;t, the proc will park itself.</span></span><br><span class="line">	<span class="comment">// If we have lots of excessive work, resetspinning will unpark additional procs as necessary.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 启动gc helper</span></span><br><span class="line">	<span class="keyword">if</span> add &#123;</span><br><span class="line">		<span class="comment">// If GC could have used another helper proc, start one now,</span></span><br><span class="line">		<span class="comment">// in the hope that it will be available next time.</span></span><br><span class="line">		<span class="comment">// It would have been even better to start it before the collection,</span></span><br><span class="line">		<span class="comment">// but doing so requires allocating memory, so it&#x27;s tricky to</span></span><br><span class="line">		<span class="comment">// coordinate. This lazy approach works out in practice:</span></span><br><span class="line">		<span class="comment">// we don&#x27;t mind if the first couple gc rounds don&#x27;t have quite</span></span><br><span class="line">		<span class="comment">// the maximum number of procs.</span></span><br><span class="line">		newm(mhelpgc, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 允许G被抢占</span></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果当前G要求被抢占则重新尝试</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we&#x27;ve cleared it in newstack</span></span><br><span class="line">		_g_.stackguard0 = stackPreempt</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启世界后各个M会重新开始调度, 调度时会优先使用上面提到的findRunnableGCWorker函数查找任务, 之后就有大约25%的P运行后台标记任务.<br>后台标记任务的函数是<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1681">gcBgMarkWorker</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用于休眠后重新获取P的构造体</span></span><br><span class="line">	<span class="keyword">type</span> parkInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">		m      muintptr <span class="comment">// Release this m on park.</span></span><br><span class="line">		attach puintptr <span class="comment">// If non-nil, attach to this p on park.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// We pass park to a gopark unlock function, so it can&#x27;t be on</span></span><br><span class="line">	<span class="comment">// the stack (see gopark). Prevent deadlock from recursively</span></span><br><span class="line">	<span class="comment">// starting GC by disabling preemption.</span></span><br><span class="line">	gp.m.preemptoff = <span class="string">&quot;GC worker init&quot;</span></span><br><span class="line">	park := <span class="built_in">new</span>(parkInfo)</span><br><span class="line">	gp.m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置当前的M并禁止抢占</span></span><br><span class="line">	park.m.set(acquirem())</span><br><span class="line">	<span class="comment">// 设置当前的P(需要关联到的P)</span></span><br><span class="line">	park.attach.set(_p_)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 通知gcBgMarkStartWorkers可以继续处理</span></span><br><span class="line">	<span class="comment">// Inform gcBgMarkStartWorkers that this worker is ready.</span></span><br><span class="line">	<span class="comment">// After this point, the background mark worker is scheduled</span></span><br><span class="line">	<span class="comment">// cooperatively by gcController.findRunnable. Hence, it must</span></span><br><span class="line">	<span class="comment">// never be preempted, as this would put it into _Grunnable</span></span><br><span class="line">	<span class="comment">// and put it on a run queue. Instead, when the preempt flag</span></span><br><span class="line">	<span class="comment">// is set, this puts itself into _Gwaiting to be woken up by</span></span><br><span class="line">	<span class="comment">// gcController.findRunnable at the appropriate time.</span></span><br><span class="line">	notewakeup(&amp;work.bgMarkReady)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 让当前G进入休眠</span></span><br><span class="line">		<span class="comment">// Go to sleep until woken by gcController.findRunnable.</span></span><br><span class="line">		<span class="comment">// We can&#x27;t releasem yet since even the call to gopark</span></span><br><span class="line">		<span class="comment">// may be preempted.</span></span><br><span class="line">		gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, parkp unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			park := (*parkInfo)(parkp)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 重新允许抢占</span></span><br><span class="line">			<span class="comment">// The worker G is no longer running, so it&#x27;s</span></span><br><span class="line">			<span class="comment">// now safe to allow preemption.</span></span><br><span class="line">			releasem(park.m.ptr())</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 设置关联的P</span></span><br><span class="line">			<span class="comment">// 把当前的G设到P的gcBgMarkWorker成员, 下次findRunnableGCWorker会使用</span></span><br><span class="line">			<span class="comment">// 设置失败时不休眠</span></span><br><span class="line">			<span class="comment">// If the worker isn&#x27;t attached to its P,</span></span><br><span class="line">			<span class="comment">// attach now. During initialization and after</span></span><br><span class="line">			<span class="comment">// a phase change, the worker may have been</span></span><br><span class="line">			<span class="comment">// running on a different P. As soon as we</span></span><br><span class="line">			<span class="comment">// attach, the owner P may schedule the</span></span><br><span class="line">			<span class="comment">// worker, so this must be done after the G is</span></span><br><span class="line">			<span class="comment">// stopped.</span></span><br><span class="line">			<span class="keyword">if</span> park.attach != <span class="number">0</span> &#123;</span><br><span class="line">				p := park.attach.ptr()</span><br><span class="line">				park.attach.set(<span class="literal">nil</span>)</span><br><span class="line">				<span class="comment">// cas the worker because we may be</span></span><br><span class="line">				<span class="comment">// racing with a new worker starting</span></span><br><span class="line">				<span class="comment">// on this P.</span></span><br><span class="line">				<span class="keyword">if</span> !p.gcBgMarkWorker.cas(<span class="number">0</span>, guintptr(unsafe.Pointer(g))) &#123;</span><br><span class="line">					<span class="comment">// The P got a new worker.</span></span><br><span class="line">					<span class="comment">// Exit this worker.</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;, unsafe.Pointer(park), <span class="string">&quot;GC worker (idle)&quot;</span>, traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务</span></span><br><span class="line">		<span class="comment">// Loop until the P dies and disassociates this</span></span><br><span class="line">		<span class="comment">// worker (the P may later be reused, in which case</span></span><br><span class="line">		<span class="comment">// it will get a new worker) or we failed to associate.</span></span><br><span class="line">		<span class="keyword">if</span> _p_.gcBgMarkWorker.ptr() != gp &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 禁止G被抢占</span></span><br><span class="line">		<span class="comment">// Disable preemption so we can use the gcw. If the</span></span><br><span class="line">		<span class="comment">// scheduler wants to preempt us, we&#x27;ll stop draining,</span></span><br><span class="line">		<span class="comment">// dispose the gcw, and then preempt.</span></span><br><span class="line">		park.m.set(acquirem())</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;gcBgMarkWorker: blackening not enabled&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 记录开始时间</span></span><br><span class="line">		startTime := nanotime()</span><br><span class="line">		</span><br><span class="line">		decnwait := atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait=&quot;</span>, decnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">			throw(<span class="string">&quot;work.nwait was &gt; work.nproc&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 切换到g0运行</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 设置G的状态为等待中这样它的栈可以被扫描(两个后台标记任务可以互相扫描对方的栈)</span></span><br><span class="line">			<span class="comment">// Mark our goroutine preemptible so its stack</span></span><br><span class="line">			<span class="comment">// can be scanned. This lets two mark workers</span></span><br><span class="line">			<span class="comment">// scan each other (otherwise, they would</span></span><br><span class="line">			<span class="comment">// deadlock). We must not modify anything on</span></span><br><span class="line">			<span class="comment">// the G stack. However, stack shrinking is</span></span><br><span class="line">			<span class="comment">// disabled for mark workers, so it is safe to</span></span><br><span class="line">			<span class="comment">// read from the G stack.</span></span><br><span class="line">			casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 判断后台标记任务的模式</span></span><br><span class="line">			<span class="keyword">switch</span> _p_.gcMarkWorkerMode &#123;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				throw(<span class="string">&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;</span>)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">				<span class="comment">// 这个模式下P应该专心执行标记</span></span><br><span class="line">				<span class="comment">// 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">				gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">				<span class="comment">// 被抢占时把本地运行队列中的所有G都踢到全局运行队列</span></span><br><span class="line">				<span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">					<span class="comment">// We were preempted. This is</span></span><br><span class="line">					<span class="comment">// a useful signal to kick</span></span><br><span class="line">					<span class="comment">// everything out of the run</span></span><br><span class="line">					<span class="comment">// queue so it can run</span></span><br><span class="line">					<span class="comment">// somewhere else.</span></span><br><span class="line">					lock(&amp;sched.lock)</span><br><span class="line">					<span class="keyword">for</span> &#123;</span><br><span class="line">						gp, _ := runqget(_p_)</span><br><span class="line">						<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">							<span class="keyword">break</span></span><br><span class="line">						&#125;</span><br><span class="line">						globrunqput(gp)</span><br><span class="line">					&#125;</span><br><span class="line">					unlock(&amp;sched.lock)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 继续执行标记, 直到无更多任务, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">				<span class="comment">// Go back to draining, this time</span></span><br><span class="line">				<span class="comment">// without preemption.</span></span><br><span class="line">				gcDrain(&amp;_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">				<span class="comment">// 这个模式下P应该适当执行标记</span></span><br><span class="line">				<span class="comment">// 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">				gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">				<span class="comment">// 这个模式下P只在空闲时执行标记</span></span><br><span class="line">				<span class="comment">// 执行标记, 直到被抢占或者达到一定的量, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">				gcDrain(&amp;_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 恢复G的状态到运行中</span></span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">		&#125;)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果标记了禁止本地标记队列则flush到全局标记队列</span></span><br><span class="line">		<span class="comment">// If we are nearing the end of mark, dispose</span></span><br><span class="line">		<span class="comment">// of the cache promptly. We must do this</span></span><br><span class="line">		<span class="comment">// before signaling that we&#x27;re no longer</span></span><br><span class="line">		<span class="comment">// working so that other workers can&#x27;t observe</span></span><br><span class="line">		<span class="comment">// no workers and no work while we have this</span></span><br><span class="line">		<span class="comment">// cached, and before we compute done.</span></span><br><span class="line">		<span class="keyword">if</span> gcBlackenPromptly &#123;</span><br><span class="line">			_p_.gcw.dispose()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 累加所用时间</span></span><br><span class="line">		<span class="comment">// Account for time.</span></span><br><span class="line">		duration := nanotime() - startTime</span><br><span class="line">		<span class="keyword">switch</span> _p_.gcMarkWorkerMode &#123;</span><br><span class="line">		<span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.dedicatedMarkTime, duration)</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.fractionalMarkTime, duration)</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.idleMarkTime, duration)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Was this the last worker and did we run out</span></span><br><span class="line">		<span class="comment">// of work?</span></span><br><span class="line">		incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: p.gcMarkWorkerMode=&quot;</span>, _p_.gcMarkWorkerMode,</span><br><span class="line">				<span class="string">&quot;work.nwait=&quot;</span>, incnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">			throw(<span class="string">&quot;work.nwait &gt; work.nproc&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 判断是否所有后台标记任务都完成, 并且没有更多的任务</span></span><br><span class="line">		<span class="comment">// If this worker reached a background mark completion</span></span><br><span class="line">		<span class="comment">// point, signal the main GC goroutine.</span></span><br><span class="line">		<span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="comment">// 取消和P的关联</span></span><br><span class="line">			<span class="comment">// Make this G preemptible and disassociate it</span></span><br><span class="line">			<span class="comment">// as the worker for this P so</span></span><br><span class="line">			<span class="comment">// findRunnableGCWorker doesn&#x27;t try to</span></span><br><span class="line">			<span class="comment">// schedule it.</span></span><br><span class="line">			_p_.gcBgMarkWorker.set(<span class="literal">nil</span>)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 允许G被抢占</span></span><br><span class="line">			releasem(park.m.ptr())</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 准备进入完成标记阶段</span></span><br><span class="line">			gcMarkDone()</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 休眠之前会重新关联P</span></span><br><span class="line">			<span class="comment">// 因为上面允许被抢占, 到这里的时候可能就会变成其他P</span></span><br><span class="line">			<span class="comment">// 如果重新关联P失败则这个任务会结束</span></span><br><span class="line">			<span class="comment">// Disable preemption and prepare to reattach</span></span><br><span class="line">			<span class="comment">// to the P.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// We may be running on a different P at this</span></span><br><span class="line">			<span class="comment">// point, so we can&#x27;t reattach until this G is</span></span><br><span class="line">			<span class="comment">// parked.</span></span><br><span class="line">			park.m.set(acquirem())</span><br><span class="line">			park.attach.set(_p_)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L889">gcDrain</a>函数用于执行标记:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcDrain scans roots and objects in work buffers, blackening grey</span></span><br><span class="line"><span class="comment">// objects until all roots and work buffers have been drained.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If flags&amp;gcDrainUntilPreempt != 0, gcDrain returns when g.preempt</span></span><br><span class="line"><span class="comment">// is set. This implies gcDrainNoBlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If flags&amp;gcDrainIdle != 0, gcDrain returns when there is other work</span></span><br><span class="line"><span class="comment">// to do. This implies gcDrainNoBlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If flags&amp;gcDrainNoBlock != 0, gcDrain returns as soon as it is</span></span><br><span class="line"><span class="comment">// unable to get more work. Otherwise, it will block until all</span></span><br><span class="line"><span class="comment">// blocking calls are blocked in gcDrain.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If flags&amp;gcDrainFlushBgCredit != 0, gcDrain flushes scan work</span></span><br><span class="line"><span class="comment">// credit to gcController.bgScanCredit every gcCreditSlack units of</span></span><br><span class="line"><span class="comment">// scan work.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !writeBarrier.needed &#123;</span><br><span class="line">		throw(<span class="string">&quot;gcDrain phase incorrect&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	gp := getg().m.curg</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 看到抢占标志时是否要返回</span></span><br><span class="line">	preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 没有任务时是否要等待任务</span></span><br><span class="line">	blocking := flags&amp;(gcDrainUntilPreempt|gcDrainIdle|gcDrainNoBlock) == <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 是否计算后台的扫描量来减少辅助GC和唤醒等待中的G</span></span><br><span class="line">	flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 是否只执行一定量的工作</span></span><br><span class="line">	idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 记录初始的已扫描数量</span></span><br><span class="line">	initScanWork := gcw.scanWork</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 扫描idleCheckThreshold(100000)个对象以后检查是否要返回</span></span><br><span class="line">	<span class="comment">// idleCheck is the scan work at which to perform the next</span></span><br><span class="line">	<span class="comment">// idle check with the scheduler.</span></span><br><span class="line">	idleCheck := initScanWork + idleCheckThreshold</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果根对象未扫描完, 则先扫描根对象</span></span><br><span class="line">	<span class="comment">// Drain root marking jobs.</span></span><br><span class="line">	<span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">		<span class="comment">// 如果标记了preemptible, 循环直到被抢占</span></span><br><span class="line">		<span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line">			<span class="comment">// 从根对象扫描队列取出一个值(原子递增)</span></span><br><span class="line">			job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 执行根对象扫描工作</span></span><br><span class="line">			markroot(gcw, job)</span><br><span class="line">			<span class="comment">// 如果是idle模式并且有其他工作, 则返回</span></span><br><span class="line">			<span class="keyword">if</span> idle &amp;&amp; pollWork() &#123;</span><br><span class="line">				<span class="keyword">goto</span> done</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根对象已经在标记队列中, 消费标记队列</span></span><br><span class="line">	<span class="comment">// 如果标记了preemptible, 循环直到被抢占</span></span><br><span class="line">	<span class="comment">// Drain heap marking jobs.</span></span><br><span class="line">	<span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt) &#123;</span><br><span class="line">		<span class="comment">// 如果全局标记队列为空, 把本地标记队列的一部分工作分过去</span></span><br><span class="line">		<span class="comment">// (如果wbuf2不为空则移动wbuf2过去, 否则移动wbuf1的一半过去)</span></span><br><span class="line">		<span class="comment">// Try to keep work available on the global queue. We used to</span></span><br><span class="line">		<span class="comment">// check if there were waiting workers, but it&#x27;s better to</span></span><br><span class="line">		<span class="comment">// just keep work available than to make workers wait. In the</span></span><br><span class="line">		<span class="comment">// worst case, we&#x27;ll do O(log(_WorkbufSize)) unnecessary</span></span><br><span class="line">		<span class="comment">// balances.</span></span><br><span class="line">		<span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">			gcw.balance()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 从本地标记队列中获取对象, 获取不到则从全局标记队列获取</span></span><br><span class="line">		<span class="keyword">var</span> b <span class="type">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> blocking &#123;</span><br><span class="line">			<span class="comment">// 阻塞获取</span></span><br><span class="line">			b = gcw.get()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 非阻塞获取</span></span><br><span class="line">			b = gcw.tryGetFast()</span><br><span class="line">			<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">				b = gcw.tryGet()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取不到对象, 标记队列已为空, 跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// work barrier reached or tryGet failed.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 扫描获取到的对象</span></span><br><span class="line">		scanobject(b, gcw)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果已经扫描了一定数量的对象(gcCreditSlack的值是2000)</span></span><br><span class="line">		<span class="comment">// Flush background scan work credit to the global</span></span><br><span class="line">		<span class="comment">// account if we&#x27;ve accumulated enough locally so</span></span><br><span class="line">		<span class="comment">// mutator assists can draw on it.</span></span><br><span class="line">		<span class="keyword">if</span> gcw.scanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">			<span class="comment">// 把扫描的对象数量添加到全局</span></span><br><span class="line">			atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">			<span class="comment">// 减少辅助GC的工作量和唤醒等待中的G</span></span><br><span class="line">			<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">				gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">				initScanWork = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			idleCheck -= gcw.scanWork</span><br><span class="line">			gcw.scanWork = <span class="number">0</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果是idle模式且达到了检查的扫描量, 则检查是否有其他任务(G), 如果有则跳出循环</span></span><br><span class="line">			<span class="keyword">if</span> idle &amp;&amp; idleCheck &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				idleCheck += idleCheckThreshold</span><br><span class="line">				<span class="keyword">if</span> pollWork() &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// In blocking mode, write barriers are not allowed after this</span></span><br><span class="line">	<span class="comment">// point because we must preserve the condition that the work</span></span><br><span class="line">	<span class="comment">// buffers are empty.</span></span><br><span class="line">	</span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// 把扫描的对象数量添加到全局</span></span><br><span class="line">	<span class="comment">// Flush remaining scan work credit.</span></span><br><span class="line">	<span class="keyword">if</span> gcw.scanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">		<span class="comment">// 减少辅助GC的工作量和唤醒等待中的G</span></span><br><span class="line">		<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">			gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">		&#125;</span><br><span class="line">		gcw.scanWork = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L178">markroot</a>函数用于执行根对象扫描工作:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// markroot scans the i&#x27;th root.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Preemption must be disabled (because this uses a gcWork).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// nowritebarrier is only advisory here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markroot</span><span class="params">(gcw *gcWork, i <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断取出的数值对应哪种任务</span></span><br><span class="line">	<span class="comment">// (google的工程师觉得这种办法可笑)</span></span><br><span class="line">	<span class="comment">// TODO(austin): This is a bit ridiculous. Compute and store</span></span><br><span class="line">	<span class="comment">// the bases in gcMarkRootPrepare instead of the counts.</span></span><br><span class="line">	baseFlushCache := <span class="type">uint32</span>(fixedRootCount)</span><br><span class="line">	baseData := baseFlushCache + <span class="type">uint32</span>(work.nFlushCacheRoots)</span><br><span class="line">	baseBSS := baseData + <span class="type">uint32</span>(work.nDataRoots)</span><br><span class="line">	baseSpans := baseBSS + <span class="type">uint32</span>(work.nBSSRoots)</span><br><span class="line">	baseStacks := baseSpans + <span class="type">uint32</span>(work.nSpanRoots)</span><br><span class="line">	end := baseStacks + <span class="type">uint32</span>(work.nStackRoots)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note: if you add a case here, please also update heapdump.go:dumproots.</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="comment">// 释放mcache中的所有span, 要求STW</span></span><br><span class="line">	<span class="keyword">case</span> baseFlushCache &lt;= i &amp;&amp; i &lt; baseData:</span><br><span class="line">		flushmcache(<span class="type">int</span>(i - baseFlushCache))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描可读写的全局变量</span></span><br><span class="line">	<span class="comment">// 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据</span></span><br><span class="line">	<span class="keyword">case</span> baseData &lt;= i &amp;&amp; i &lt; baseBSS:</span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">			markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, <span class="type">int</span>(i-baseData))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描只读的全局变量</span></span><br><span class="line">	<span class="comment">// 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据</span></span><br><span class="line">	<span class="keyword">case</span> baseBSS &lt;= i &amp;&amp; i &lt; baseSpans:</span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">			markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, <span class="type">int</span>(i-baseBSS))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描析构器队列</span></span><br><span class="line">	<span class="keyword">case</span> i == fixedRootFinalizers:</span><br><span class="line">		<span class="comment">// Only do this once per GC cycle since we don&#x27;t call</span></span><br><span class="line">		<span class="comment">// queuefinalizer during marking.</span></span><br><span class="line">		<span class="keyword">if</span> work.markrootDone &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">			cnt := <span class="type">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">			scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放已中止的G的栈</span></span><br><span class="line">	<span class="keyword">case</span> i == fixedRootFreeGStacks:</span><br><span class="line">		<span class="comment">// Only do this once per GC cycle; preferably</span></span><br><span class="line">		<span class="comment">// concurrently.</span></span><br><span class="line">		<span class="keyword">if</span> !work.markrootDone &#123;</span><br><span class="line">			<span class="comment">// Switch to the system stack so we can call</span></span><br><span class="line">			<span class="comment">// stackfree.</span></span><br><span class="line">			systemstack(markrootFreeGStacks)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描各个span中特殊对象(析构器列表)</span></span><br><span class="line">	<span class="keyword">case</span> baseSpans &lt;= i &amp;&amp; i &lt; baseStacks:</span><br><span class="line">		<span class="comment">// mark MSpan.specials</span></span><br><span class="line">		markrootSpans(gcw, <span class="type">int</span>(i-baseSpans))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描各个G的栈</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 获取需要扫描的G</span></span><br><span class="line">		<span class="comment">// the rest is scanning goroutine stacks</span></span><br><span class="line">		<span class="keyword">var</span> gp *g</span><br><span class="line">		<span class="keyword">if</span> baseStacks &lt;= i &amp;&amp; i &lt; end &#123;</span><br><span class="line">			gp = allgs[i-baseStacks]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;markroot: bad index&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录等待开始的时间</span></span><br><span class="line">		<span class="comment">// remember when we&#x27;ve first observed the G blocked</span></span><br><span class="line">		<span class="comment">// needed only to output in traceback</span></span><br><span class="line">		status := readgstatus(gp) <span class="comment">// We are not in a scan state</span></span><br><span class="line">		<span class="keyword">if</span> (status == _Gwaiting || status == _Gsyscall) &amp;&amp; gp.waitsince == <span class="number">0</span> &#123;</span><br><span class="line">			gp.waitsince = work.tstart</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 切换到g0运行(有可能会扫到自己的栈)</span></span><br><span class="line">		<span class="comment">// scang must be done on the system stack in case</span></span><br><span class="line">		<span class="comment">// we&#x27;re trying to scan our own stack.</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 判断扫描的栈是否自己的</span></span><br><span class="line">			<span class="comment">// If this is a self-scan, put the user G in</span></span><br><span class="line">			<span class="comment">// _Gwaiting to prevent self-deadlock. It may</span></span><br><span class="line">			<span class="comment">// already be in _Gwaiting if this is a mark</span></span><br><span class="line">			<span class="comment">// worker or we&#x27;re in mark termination.</span></span><br><span class="line">			userG := getg().m.curg</span><br><span class="line">			selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果正在扫描自己的栈则切换状态到等待中防止死锁</span></span><br><span class="line">			<span class="keyword">if</span> selfScan &#123;</span><br><span class="line">				casgstatus(userG, _Grunning, _Gwaiting)</span><br><span class="line">				userG.waitreason = <span class="string">&quot;garbage collection scan&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 扫描G的栈</span></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> scang blocks until gp&#x27;s stack has</span></span><br><span class="line">			<span class="comment">// been scanned, which may take a while for</span></span><br><span class="line">			<span class="comment">// running goroutines. Consider doing this in</span></span><br><span class="line">			<span class="comment">// two phases where the first is non-blocking:</span></span><br><span class="line">			<span class="comment">// we scan the stacks we can and ask running</span></span><br><span class="line">			<span class="comment">// goroutines to scan themselves; and the</span></span><br><span class="line">			<span class="comment">// second blocks.</span></span><br><span class="line">			scang(gp, gcw)</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 如果正在扫描自己的栈则把状态切换回运行中</span></span><br><span class="line">			<span class="keyword">if</span> selfScan &#123;</span><br><span class="line">				casgstatus(userG, _Gwaiting, _Grunning)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L830">scang</a>函数负责扫描G的栈:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scang blocks until gp&#x27;s stack has been scanned.</span></span><br><span class="line"><span class="comment">// It might be scanned by scang or it might be scanned by the goroutine itself.</span></span><br><span class="line"><span class="comment">// Either way, the stack scan has completed when scang returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scang</span><span class="params">(gp *g, gcw *gcWork)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Invariant; we (the caller, markroot for a specific goroutine) own gp.gcscandone.</span></span><br><span class="line">	<span class="comment">// Nothing is racing with us now, but gcscandone might be set to true left over</span></span><br><span class="line">	<span class="comment">// from an earlier round of stack scanning (we scan twice per GC).</span></span><br><span class="line">	<span class="comment">// We use gcscandone to record whether the scan has been done during this round.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记扫描未完成</span></span><br><span class="line">	gp.gcscandone = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// See http://golang.org/cl/21503 for justification of the yield delay.</span></span><br><span class="line">	<span class="keyword">const</span> yieldDelay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">	<span class="keyword">var</span> nextYield <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环直到扫描完成</span></span><br><span class="line">	<span class="comment">// Endeavor to get gcscandone set to true,</span></span><br><span class="line">	<span class="comment">// either by doing the stack scan ourselves or by coercing gp to scan itself.</span></span><br><span class="line">	<span class="comment">// gp.gcscandone can transition from false to true when we&#x27;re not looking</span></span><br><span class="line">	<span class="comment">// (if we asked for preemption), so any time we lock the status using</span></span><br><span class="line">	<span class="comment">// castogscanstatus we have to double-check that the scan is still not done.</span></span><br><span class="line">loop:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; !gp.gcscandone; i++ &#123;</span><br><span class="line">		<span class="comment">// 判断G的当前状态</span></span><br><span class="line">		<span class="keyword">switch</span> s := readgstatus(gp); s &#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			dumpgstatus(gp)</span><br><span class="line">			throw(<span class="string">&quot;stopg: invalid status&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// G已中止, 不需要扫描它</span></span><br><span class="line">		<span class="keyword">case</span> _Gdead:</span><br><span class="line">			<span class="comment">// No stack.</span></span><br><span class="line">			gp.gcscandone = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span> loop</span><br><span class="line"></span><br><span class="line">		<span class="comment">// G的栈正在扩展, 下一轮重试</span></span><br><span class="line">		<span class="keyword">case</span> _Gcopystack:</span><br><span class="line">		<span class="comment">// Stack being switched. Go around again.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// G不是运行中, 首先需要防止它运行</span></span><br><span class="line">		<span class="keyword">case</span> _Grunnable, _Gsyscall, _Gwaiting:</span><br><span class="line">			<span class="comment">// Claim goroutine by setting scan bit.</span></span><br><span class="line">			<span class="comment">// Racing with execution or readying of gp.</span></span><br><span class="line">			<span class="comment">// The scan bit keeps them from running</span></span><br><span class="line">			<span class="comment">// the goroutine until we&#x27;re done.</span></span><br><span class="line">			<span class="keyword">if</span> castogscanstatus(gp, s, s|_Gscan) &#123;</span><br><span class="line">				<span class="comment">// 原子切换状态成功时扫描它的栈</span></span><br><span class="line">				<span class="keyword">if</span> !gp.gcscandone &#123;</span><br><span class="line">					scanstack(gp, gcw)</span><br><span class="line">					gp.gcscandone = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 恢复G的状态, 并跳出循环</span></span><br><span class="line">				restartg(gp)</span><br><span class="line">				<span class="keyword">break</span> loop</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// G正在扫描它自己, 等待扫描完毕</span></span><br><span class="line">		<span class="keyword">case</span> _Gscanwaiting:</span><br><span class="line">		<span class="comment">// newstack is doing a scan for us right now. Wait.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// G正在运行</span></span><br><span class="line">		<span class="keyword">case</span> _Grunning:</span><br><span class="line">			<span class="comment">// Goroutine running. Try to preempt execution so it can scan itself.</span></span><br><span class="line">			<span class="comment">// The preemption handler (in newstack) does the actual scan.</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果已经有抢占请求, 则抢占成功时会帮我们处理</span></span><br><span class="line">			<span class="comment">// Optimization: if there is already a pending preemption request</span></span><br><span class="line">			<span class="comment">// (from the previous loop iteration), don&#x27;t bother with the atomics.</span></span><br><span class="line">			<span class="keyword">if</span> gp.preemptscan &amp;&amp; gp.preempt &amp;&amp; gp.stackguard0 == stackPreempt &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 抢占G, 抢占成功时G会扫描它自己</span></span><br><span class="line">			<span class="comment">// Ask for preemption and self scan.</span></span><br><span class="line">			<span class="keyword">if</span> castogscanstatus(gp, _Grunning, _Gscanrunning) &#123;</span><br><span class="line">				<span class="keyword">if</span> !gp.gcscandone &#123;</span><br><span class="line">					gp.preemptscan = <span class="literal">true</span></span><br><span class="line">					gp.preempt = <span class="literal">true</span></span><br><span class="line">					gp.stackguard0 = stackPreempt</span><br><span class="line">				&#125;</span><br><span class="line">				casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一轮休眠10毫秒, 第二轮休眠5毫秒</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			nextYield = nanotime() + yieldDelay</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> nanotime() &lt; nextYield &#123;</span><br><span class="line">			procyield(<span class="number">10</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			osyield()</span><br><span class="line">			nextYield = nanotime() + yieldDelay/<span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描完成, 取消抢占扫描的请求</span></span><br><span class="line">	gp.preemptscan = <span class="literal">false</span> <span class="comment">// cancel scan request if no longer needed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置preemptscan后, 在抢占G成功时会调用scanstack扫描它自己的栈, 具体代码<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/stack.go#L1013">在这里</a>.<br>扫描栈用的函数是<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L736">scanstack</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scanstack scans gp&#x27;s stack, greying all pointers found on the stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// scanstack is marked go:systemstack because it must not be preempted</span></span><br><span class="line"><span class="comment">// while using a workbuf.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanstack</span><span class="params">(gp *g, gcw *gcWork)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> gp.gcscanvalid &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> readgstatus(gp)&amp;_Gscan == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime:scanstack: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, hex(readgstatus(gp)), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;scanstack - bad status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> readgstatus(gp) &amp;^ _Gscan &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, readgstatus(gp), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;mark - bad status&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> _Gdead:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> _Grunning:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: gp=&quot;</span>, gp, <span class="string">&quot;, goid=&quot;</span>, gp.goid, <span class="string">&quot;, gp-&gt;atomicstatus=&quot;</span>, readgstatus(gp), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;scanstack: goroutine not stopped&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> _Grunnable, _Gsyscall, _Gwaiting:</span><br><span class="line">		<span class="comment">// ok</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gp == getg() &#123;</span><br><span class="line">		throw(<span class="string">&quot;can&#x27;t scan our own stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp := gp.m</span><br><span class="line">	<span class="keyword">if</span> mp != <span class="literal">nil</span> &amp;&amp; mp.helpgc != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;can&#x27;t scan gchelper stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Shrink the stack if not much of it is being used. During</span></span><br><span class="line">	<span class="comment">// concurrent GC, we can do this during concurrent mark.</span></span><br><span class="line">	<span class="keyword">if</span> !work.markrootDone &#123;</span><br><span class="line">		shrinkstack(gp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scan the stack.</span></span><br><span class="line">	<span class="keyword">var</span> cache pcvalueCache</span><br><span class="line">	scanframe := <span class="function"><span class="keyword">func</span><span class="params">(frame *stkframe, unused unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// scanframeworker会根据代码地址(pc)获取函数信息</span></span><br><span class="line">		<span class="comment">// 然后找到函数信息中的stackmap.bytedata, 它保存了函数的栈上哪些地方有指针</span></span><br><span class="line">		<span class="comment">// 再调用scanblock来扫描函数的栈空间, 同时函数的参数也会这样扫描</span></span><br><span class="line">		scanframeworker(frame, &amp;cache, gcw)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 枚举所有调用帧, 分别调用scanframe函数</span></span><br><span class="line">	gentraceback(^<span class="type">uintptr</span>(<span class="number">0</span>), ^<span class="type">uintptr</span>(<span class="number">0</span>), <span class="number">0</span>, gp, <span class="number">0</span>, <span class="literal">nil</span>, <span class="number">0x7fffffff</span>, scanframe, <span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 枚举所有defer的调用帧, 分别调用scanframe函数</span></span><br><span class="line">	tracebackdefers(gp, scanframe, <span class="literal">nil</span>)</span><br><span class="line">	gp.gcscanvalid = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1059">scanblock</a>函数是一个通用的扫描函数, 扫描全局变量和栈空间都会用它, 和scanobject不同的是bitmap需要手动传入:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scanblock scans b as scanobject would, but using an explicit</span></span><br><span class="line"><span class="comment">// pointer bitmap instead of the heap bitmap.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is used to scan non-heap roots, so it does not update</span></span><br><span class="line"><span class="comment">// gcw.bytesMarked or gcw.scanWork.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanblock</span><span class="params">(b0, n0 <span class="type">uintptr</span>, ptrmask *<span class="type">uint8</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Use local copies of original parameters, so that a stack trace</span></span><br><span class="line">	<span class="comment">// due to one of the throws below shows the original block</span></span><br><span class="line">	<span class="comment">// base and extent.</span></span><br><span class="line">	b := b0</span><br><span class="line">	n := n0</span><br><span class="line"></span><br><span class="line">	arena_start := mheap_.arena_start</span><br><span class="line">	arena_used := mheap_.arena_used</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 枚举扫描的地址</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; &#123;</span><br><span class="line">		<span class="comment">// 找到bitmap中对应的byte</span></span><br><span class="line">		<span class="comment">// Find bits for the next word.</span></span><br><span class="line">		bits := <span class="type">uint32</span>(*addb(ptrmask, i/(sys.PtrSize*<span class="number">8</span>)))</span><br><span class="line">		<span class="keyword">if</span> bits == <span class="number">0</span> &#123;</span><br><span class="line">			i += sys.PtrSize * <span class="number">8</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 枚举byte</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span> &amp;&amp; i &lt; n; j++ &#123;</span><br><span class="line">			<span class="comment">// 如果该地址包含指针</span></span><br><span class="line">			<span class="keyword">if</span> bits&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 标记在该地址的对象存活, 并把它加到标记队列(该对象变为灰色)</span></span><br><span class="line">				<span class="comment">// Same work as in scanobject; see comments there.</span></span><br><span class="line">				obj := *(*<span class="type">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line">				<span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; arena_start &lt;= obj &amp;&amp; obj &lt; arena_used &#123;</span><br><span class="line">					<span class="comment">// 找到该对象对应的span和bitmap</span></span><br><span class="line">					<span class="keyword">if</span> obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">						<span class="comment">// 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)</span></span><br><span class="line">						greyobject(obj, b, i, hbits, span, gcw, objIndex)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 处理下一个指针下一个bit</span></span><br><span class="line">			bits &gt;&gt;= <span class="number">1</span></span><br><span class="line">			i += sys.PtrSize</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1216">greyobject</a>用于标记一个对象存活, 并把它加到标记队列(该对象变为灰色):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj is the start of an object with mark mbits.</span></span><br><span class="line"><span class="comment">// If it isn&#x27;t already marked, mark it and enqueue into gcw.</span></span><br><span class="line"><span class="comment">// base and off are for debugging only and could be removed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greyobject</span><span class="params">(obj, base, off <span class="type">uintptr</span>, hbits heapBits, span *mspan, gcw *gcWork, objIndex <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// obj should be start of allocation, and so must be at least pointer-aligned.</span></span><br><span class="line">	<span class="keyword">if</span> obj&amp;(sys.PtrSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;greyobject: obj not pointer-aligned&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mbits := span.markBitsForIndex(objIndex)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line">		<span class="comment">// checkmark是用于检查是否所有可到达的对象都被正确标记的机制, 仅除错使用</span></span><br><span class="line">		<span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line">			printlock()</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime:greyobject: checkmarks finds unexpected unmarked object obj=&quot;</span>, hex(obj), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: found obj at *(&quot;</span>, hex(base), <span class="string">&quot;+&quot;</span>, hex(off), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Dump the source (base) object</span></span><br><span class="line">			gcDumpObject(<span class="string">&quot;base&quot;</span>, base, off)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Dump the object</span></span><br><span class="line">			gcDumpObject(<span class="string">&quot;obj&quot;</span>, obj, ^<span class="type">uintptr</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">			getg().m.traceback = <span class="number">2</span></span><br><span class="line">			throw(<span class="string">&quot;checkmark found unmarked object&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> hbits.isCheckmarked(span.elemsize) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		hbits.setCheckmarked(span.elemsize)</span><br><span class="line">		<span class="keyword">if</span> !hbits.isCheckmarked(span.elemsize) &#123;</span><br><span class="line">			throw(<span class="string">&quot;setCheckmarked and isCheckmarked disagree&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &amp;&amp; span.isFree(objIndex) &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: marking free object &quot;</span>, hex(obj), <span class="string">&quot; found at *(&quot;</span>, hex(base), <span class="string">&quot;+&quot;</span>, hex(off), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">			gcDumpObject(<span class="string">&quot;base&quot;</span>, base, off)</span><br><span class="line">			gcDumpObject(<span class="string">&quot;obj&quot;</span>, obj, ^<span class="type">uintptr</span>(<span class="number">0</span>))</span><br><span class="line">			getg().m.traceback = <span class="number">2</span></span><br><span class="line">			throw(<span class="string">&quot;marking free object&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果对象所在的span中的gcmarkBits对应的bit已经设置为1则可以跳过处理</span></span><br><span class="line">		<span class="comment">// If marked we have nothing to do.</span></span><br><span class="line">		<span class="keyword">if</span> mbits.isMarked() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 设置对象所在的span中的gcmarkBits对应的bit为1</span></span><br><span class="line">		<span class="comment">// mbits.setMarked() // Avoid extra call overhead with manual inlining.</span></span><br><span class="line">		atomic.Or8(mbits.bytep, mbits.mask)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果确定对象不包含指针(所在span的类型是noscan), 则不需要把对象放入标记队列</span></span><br><span class="line">		<span class="comment">// If this is a noscan object, fast-track it to black</span></span><br><span class="line">		<span class="comment">// instead of greying it.</span></span><br><span class="line">		<span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">			gcw.bytesMarked += <span class="type">uint64</span>(span.elemsize)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把对象放入标记队列</span></span><br><span class="line">	<span class="comment">// 先放入本地标记队列, 失败时把本地标记队列中的部分工作转移到全局标记队列, 再放入本地标记队列</span></span><br><span class="line">	<span class="comment">// Queue the obj for scanning. The PREFETCH(obj) logic has been removed but</span></span><br><span class="line">	<span class="comment">// seems like a nice optimization that can be added back in.</span></span><br><span class="line">	<span class="comment">// There needs to be time between the PREFETCH and the use.</span></span><br><span class="line">	<span class="comment">// Previously we put the obj in an 8 element buffer that is drained at a rate</span></span><br><span class="line">	<span class="comment">// to give the PREFETCH time to do its work.</span></span><br><span class="line">	<span class="comment">// Use of PREFETCHNTA might be more appropriate than PREFETCH</span></span><br><span class="line">	<span class="keyword">if</span> !gcw.putFast(obj) &#123;</span><br><span class="line">		gcw.put(obj)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcDrain函数扫描完根对象, 就会开始消费标记队列, 对从标记队列中取出的对象调用<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1098">scanobject</a>函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scanobject scans the object starting at b, adding pointers to gcw.</span></span><br><span class="line"><span class="comment">// b must point to the beginning of a heap object or an oblet.</span></span><br><span class="line"><span class="comment">// scanobject consults the GC bitmap for the pointer mask and the</span></span><br><span class="line"><span class="comment">// spans for the size of the object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="type">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Note that arena_used may change concurrently during</span></span><br><span class="line">	<span class="comment">// scanobject and hence scanobject may encounter a pointer to</span></span><br><span class="line">	<span class="comment">// a newly allocated heap object that is *not* in</span></span><br><span class="line">	<span class="comment">// [start,used). It will not mark this object; however, we</span></span><br><span class="line">	<span class="comment">// know that it was just installed by a mutator, which means</span></span><br><span class="line">	<span class="comment">// that mutator will execute a write barrier and take care of</span></span><br><span class="line">	<span class="comment">// marking it. This is even more pronounced on relaxed memory</span></span><br><span class="line">	<span class="comment">// architectures since we access arena_used without barriers</span></span><br><span class="line">	<span class="comment">// or synchronization, but the same logic applies.</span></span><br><span class="line">	arena_start := mheap_.arena_start</span><br><span class="line">	arena_used := mheap_.arena_used</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the bits for b and the size of the object at b.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// b is either the beginning of an object, in which case this</span></span><br><span class="line">	<span class="comment">// is the size of the object to scan, or it points to an</span></span><br><span class="line">	<span class="comment">// oblet, in which case we compute the size to scan below.</span></span><br><span class="line">	<span class="comment">// 获取对象对应的bitmap</span></span><br><span class="line">	hbits := heapBitsForAddr(b)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取对象所在的span</span></span><br><span class="line">	s := spanOfUnchecked(b)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取对象的大小</span></span><br><span class="line">	n := s.elemsize</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;scanobject n == 0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对象大小过大时(maxObletBytes是128KB)需要分割扫描</span></span><br><span class="line">	<span class="comment">// 每次最多只扫描128KB</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">		<span class="comment">// Large object. Break into oblets for better</span></span><br><span class="line">		<span class="comment">// parallelism and lower latency.</span></span><br><span class="line">		<span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line">			<span class="comment">// It&#x27;s possible this is a noscan object (not</span></span><br><span class="line">			<span class="comment">// from greyobject, but from other code</span></span><br><span class="line">			<span class="comment">// paths), in which case we must *not* enqueue</span></span><br><span class="line">			<span class="comment">// oblets since their bitmaps will be</span></span><br><span class="line">			<span class="comment">// uninitialized.</span></span><br><span class="line">			<span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line">				<span class="comment">// Bypass the whole scan.</span></span><br><span class="line">				gcw.bytesMarked += <span class="type">uint64</span>(n)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Enqueue the other oblets to scan later.</span></span><br><span class="line">			<span class="comment">// Some oblets may be in b&#x27;s scalar tail, but</span></span><br><span class="line">			<span class="comment">// these will be marked as &quot;no more pointers&quot;,</span></span><br><span class="line">			<span class="comment">// so we&#x27;ll drop out immediately when we go to</span></span><br><span class="line">			<span class="comment">// scan those.</span></span><br><span class="line">			<span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line">				<span class="keyword">if</span> !gcw.putFast(oblet) &#123;</span><br><span class="line">					gcw.put(oblet)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Compute the size of the oblet. Since this object</span></span><br><span class="line">		<span class="comment">// must be a large object, s.base() is the beginning</span></span><br><span class="line">		<span class="comment">// of the object.</span></span><br><span class="line">		n = s.base() + s.elemsize - b</span><br><span class="line">		<span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">			n = maxObletBytes</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描对象中的指针</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">uintptr</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n; i += sys.PtrSize &#123;</span><br><span class="line">		<span class="comment">// 获取对应的bit</span></span><br><span class="line">		<span class="comment">// Find bits for this word.</span></span><br><span class="line">		<span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Avoid needless hbits.next() on last iteration.</span></span><br><span class="line">			hbits = hbits.next()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Load bits once. See CL 22712 and issue 16973 for discussion.</span></span><br><span class="line">		bits := hbits.bits()</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查scan bit判断是否继续扫描, 注意第二个scan bit是checkmark</span></span><br><span class="line">		<span class="comment">// During checkmarking, 1-word objects store the checkmark</span></span><br><span class="line">		<span class="comment">// in the type bit for the one word. The only one-word objects</span></span><br><span class="line">		<span class="comment">// are pointers, or else they&#x27;d be merged with other non-pointer</span></span><br><span class="line">		<span class="comment">// data into larger allocations.</span></span><br><span class="line">		<span class="keyword">if</span> i != <span class="number">1</span>*sys.PtrSize &amp;&amp; bits&amp;bitScan == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// no more pointers in this object</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查pointer bit, 不是指针则继续</span></span><br><span class="line">		<span class="keyword">if</span> bits&amp;bitPointer == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span> <span class="comment">// not a pointer</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 取出指针的值</span></span><br><span class="line">		<span class="comment">// Work here is duplicated in scanblock and above.</span></span><br><span class="line">		<span class="comment">// If you make changes here, make changes there too.</span></span><br><span class="line">		obj := *(*<span class="type">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果指针在arena区域中, 则调用greyobject标记对象并把对象放到标记队列中</span></span><br><span class="line">		<span class="comment">// At this point we have extracted the next potential pointer.</span></span><br><span class="line">		<span class="comment">// Check if it points into heap and not back at the current object.</span></span><br><span class="line">		<span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; arena_start &lt;= obj &amp;&amp; obj &lt; arena_used &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line">			<span class="comment">// Mark the object.</span></span><br><span class="line">			<span class="keyword">if</span> obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">				greyobject(obj, b, i, hbits, span, gcw, objIndex)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 统计扫描过的大小和对象数量</span></span><br><span class="line">	gcw.bytesMarked += <span class="type">uint64</span>(n)</span><br><span class="line">	gcw.scanWork += <span class="type">int64</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在所有后台标记任务都把标记队列消费完毕时, 会执行<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1345">gcMarkDone</a>函数准备进入完成标记阶段(mark termination):<br>在并行GC中gcMarkDone会被执行两次, 第一次会禁止本地标记队列然后重新开始后台标记任务, 第二次会进入完成标记阶段(mark termination)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcMarkDone transitions the GC from mark 1 to mark 2 and from mark 2</span></span><br><span class="line"><span class="comment">// to mark termination.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This should be called when all mark work has been drained. In mark</span></span><br><span class="line"><span class="comment">// 1, this includes all root marking jobs, global work buffers, and</span></span><br><span class="line"><span class="comment">// active work buffers in assists and background workers; however,</span></span><br><span class="line"><span class="comment">// work may still be cached in per-P work buffers. In mark 2, per-P</span></span><br><span class="line"><span class="comment">// caches are disabled.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The calling context must be preemptible.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that it is explicitly okay to have write barriers in this</span></span><br><span class="line"><span class="comment">// function because completion of concurrent mark is best-effort</span></span><br><span class="line"><span class="comment">// anyway. Any work created by write barriers here will be cleaned up</span></span><br><span class="line"><span class="comment">// by mark termination.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">top:</span><br><span class="line">	semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line">	<span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line">		semrelease(&amp;work.markDoneSema)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 暂时禁止启动新的后台标记任务</span></span><br><span class="line">	<span class="comment">// Disallow starting new workers so that any remaining workers</span></span><br><span class="line">	<span class="comment">// in the current mark phase will drain out.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// TODO(austin): Should dedicated workers keep an eye on this</span></span><br><span class="line">	<span class="comment">// and exit gcDrain promptly?</span></span><br><span class="line">	atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">-0xffffffff</span>)</span><br><span class="line">	atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, <span class="number">-0xffffffff</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断本地标记队列是否已禁用</span></span><br><span class="line">	<span class="keyword">if</span> !gcBlackenPromptly &#123;</span><br><span class="line">		<span class="comment">// 本地标记队列是否未禁用, 禁用然后重新开始后台标记任务</span></span><br><span class="line">		<span class="comment">// Transition from mark 1 to mark 2.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// The global work list is empty, but there can still be work</span></span><br><span class="line">		<span class="comment">// sitting in the per-P work caches.</span></span><br><span class="line">		<span class="comment">// Flush and disable work caches.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 禁用本地标记队列</span></span><br><span class="line">		<span class="comment">// Disallow caching workbufs and indicate that we&#x27;re in mark 2.</span></span><br><span class="line">		gcBlackenPromptly = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prevent completion of mark 2 until we&#x27;ve flushed</span></span><br><span class="line">		<span class="comment">// cached workbufs.</span></span><br><span class="line">		atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// GC is set up for mark 2. Let Gs blocked on the</span></span><br><span class="line">		<span class="comment">// transition lock go while we flush caches.</span></span><br><span class="line">		semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 把所有本地标记队列中的对象都推到全局标记队列</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// Flush all currently cached workbufs and</span></span><br><span class="line">			<span class="comment">// ensure all Ps see gcBlackenPromptly. This</span></span><br><span class="line">			<span class="comment">// also blocks until any remaining mark 1</span></span><br><span class="line">			<span class="comment">// workers have exited their loop so we can</span></span><br><span class="line">			<span class="comment">// start new mark 2 workers.</span></span><br><span class="line">			forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">				_p_.gcw.dispose()</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 除错用</span></span><br><span class="line">		<span class="comment">// Check that roots are marked. We should be able to</span></span><br><span class="line">		<span class="comment">// do this before the forEachP, but based on issue</span></span><br><span class="line">		<span class="comment">// #16083 there may be a (harmless) race where we can</span></span><br><span class="line">		<span class="comment">// enter mark 2 while some workers are still scanning</span></span><br><span class="line">		<span class="comment">// stacks. The forEachP ensures these scans are done.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// TODO(austin): Figure out the race and fix this</span></span><br><span class="line">		<span class="comment">// properly.</span></span><br><span class="line">		gcMarkRootCheck()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 允许启动新的后台标记任务</span></span><br><span class="line">		<span class="comment">// Now we can start up mark 2 workers.</span></span><br><span class="line">		atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">0xffffffff</span>)</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, <span class="number">0xffffffff</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果确定没有更多的任务则可以直接跳到函数顶部</span></span><br><span class="line">		<span class="comment">// 这样就当作是第二次调用了</span></span><br><span class="line">		incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="comment">// This loop will make progress because</span></span><br><span class="line">			<span class="comment">// gcBlackenPromptly is now true, so it won&#x27;t</span></span><br><span class="line">			<span class="comment">// take this same &quot;if&quot; branch.</span></span><br><span class="line">			<span class="keyword">goto</span> top</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 记录完成标记阶段开始的时间和STW开始的时间</span></span><br><span class="line">		<span class="comment">// Transition to mark termination.</span></span><br><span class="line">		now := nanotime()</span><br><span class="line">		work.tMarkTerm = now</span><br><span class="line">		work.pauseStart = now</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 禁止G被抢占</span></span><br><span class="line">		getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 停止所有运行中的G, 并禁止它们运行</span></span><br><span class="line">		systemstack(stopTheWorldWithSema)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">		<span class="comment">// 世界已停止(STW)...</span></span><br><span class="line">		<span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// The gcphase is _GCmark, it will transition to _GCmarktermination</span></span><br><span class="line">		<span class="comment">// below. The important thing is that the wb remains active until</span></span><br><span class="line">		<span class="comment">// all marking is complete. This includes writes made by the GC.</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 标记对根对象的扫描已完成, 会影响gcMarkRootPrepare中的处理</span></span><br><span class="line">		<span class="comment">// Record that one root marking pass has completed.</span></span><br><span class="line">		work.markrootDone = <span class="literal">true</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 禁止辅助GC和后台标记任务的运行</span></span><br><span class="line">		<span class="comment">// Disable assists and background workers. We must do</span></span><br><span class="line">		<span class="comment">// this before waking blocked assists.</span></span><br><span class="line">		atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 唤醒所有因为辅助GC而休眠的G</span></span><br><span class="line">		<span class="comment">// Wake all blocked assists. These will run when we</span></span><br><span class="line">		<span class="comment">// start the world again.</span></span><br><span class="line">		gcWakeAllAssists()</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Likewise, release the transition lock. Blocked</span></span><br><span class="line">		<span class="comment">// workers and assists will run when we start the</span></span><br><span class="line">		<span class="comment">// world again.</span></span><br><span class="line">		semrelease(&amp;work.markDoneSema)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 计算下一次触发gc需要的heap大小</span></span><br><span class="line">		<span class="comment">// endCycle depends on all gcWork cache stats being</span></span><br><span class="line">		<span class="comment">// flushed. This is ensured by mark 2.</span></span><br><span class="line">		nextTriggerRatio := gcController.endCycle()</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 进入完成标记阶段, 会重新启动世界</span></span><br><span class="line">		<span class="comment">// Perform mark termination. This will restart the world.</span></span><br><span class="line">		gcMarkTermination(nextTriggerRatio)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1449">gcMarkTermination</a>函数会进入完成标记阶段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTermination</span><span class="params">(nextTriggerRatio <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// World is stopped.</span></span><br><span class="line">	<span class="comment">// Start marktermination which includes enabling the write barrier.</span></span><br><span class="line">	<span class="comment">// 禁止辅助GC和后台标记任务的运行</span></span><br><span class="line">	atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 重新允许本地标记队列(下次GC使用)</span></span><br><span class="line">	gcBlackenPromptly = <span class="literal">false</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置当前GC阶段到完成标记阶段, 并启用写屏障</span></span><br><span class="line">	setGCPhase(_GCmarktermination)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录开始时间</span></span><br><span class="line">	work.heap1 = memstats.heap_live</span><br><span class="line">	startTime := nanotime()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 禁止G被抢占</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	mp.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.traceback = <span class="number">2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置G的状态为等待中这样它的栈可以被扫描</span></span><br><span class="line">	gp := _g_.m.curg</span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	gp.waitreason = <span class="string">&quot;garbage collection&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 切换到g0运行</span></span><br><span class="line">	<span class="comment">// Run gc on the g0 stack. We do this so that the g stack</span></span><br><span class="line">	<span class="comment">// we&#x27;re currently running on will no longer change. Cuts</span></span><br><span class="line">	<span class="comment">// the root set down a bit (g0 stacks are not scanned, and</span></span><br><span class="line">	<span class="comment">// we don&#x27;t need to scan gc&#x27;s internal state).  We also</span></span><br><span class="line">	<span class="comment">// need to switch to g0 so we can shrink the stack.</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 开始STW中的标记</span></span><br><span class="line">		gcMark(startTime)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 必须立刻返回, 因为外面的G的栈有可能被移动, 不能在这之后访问外面的变量</span></span><br><span class="line">		<span class="comment">// Must return immediately.</span></span><br><span class="line">		<span class="comment">// The outer function&#x27;s stack may have moved</span></span><br><span class="line">		<span class="comment">// during gcMark (it shrinks stacks, including the</span></span><br><span class="line">		<span class="comment">// outer function&#x27;s stack), so we must not refer</span></span><br><span class="line">		<span class="comment">// to any of its variables. Return back to the</span></span><br><span class="line">		<span class="comment">// non-system stack to pick up the new addresses</span></span><br><span class="line">		<span class="comment">// before continuing.</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新切换到g0运行</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		work.heap2 = work.bytesMarked</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果启用了checkmark则执行检查, 检查是否所有可到达的对象都有标记</span></span><br><span class="line">		<span class="keyword">if</span> debug.gccheckmark &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Run a full stop-the-world mark using checkmark bits,</span></span><br><span class="line">			<span class="comment">// to check that we didn&#x27;t forget to mark anything during</span></span><br><span class="line">			<span class="comment">// the concurrent mark process.</span></span><br><span class="line">			gcResetMarkState()</span><br><span class="line">			initCheckmarks()</span><br><span class="line">			gcMark(startTime)</span><br><span class="line">			clearCheckmarks()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置当前GC阶段到关闭, 并禁用写屏障</span></span><br><span class="line">		<span class="comment">// marking is complete so we can turn the write barrier off</span></span><br><span class="line">		setGCPhase(_GCoff)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 唤醒后台清扫任务, 将在STW结束后开始运行</span></span><br><span class="line">		gcSweep(work.mode)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 除错用</span></span><br><span class="line">		<span class="keyword">if</span> debug.gctrace &gt; <span class="number">1</span> &#123;</span><br><span class="line">			startTime = nanotime()</span><br><span class="line">			<span class="comment">// The g stacks have been scanned so</span></span><br><span class="line">			<span class="comment">// they have gcscanvalid==true and gcworkdone==true.</span></span><br><span class="line">			<span class="comment">// Reset these so that all stacks will be rescanned.</span></span><br><span class="line">			gcResetMarkState()</span><br><span class="line">			finishsweep_m()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Still in STW but gcphase is _GCoff, reset to _GCmarktermination</span></span><br><span class="line">			<span class="comment">// At this point all objects will be found during the gcMark which</span></span><br><span class="line">			<span class="comment">// does a complete STW mark and object scan.</span></span><br><span class="line">			setGCPhase(_GCmarktermination)</span><br><span class="line">			gcMark(startTime)</span><br><span class="line">			setGCPhase(_GCoff) <span class="comment">// marking is done, turn off wb.</span></span><br><span class="line">			gcSweep(work.mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置G的状态为运行中</span></span><br><span class="line">	_g_.m.traceback = <span class="number">0</span></span><br><span class="line">	casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跟踪处理</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCDone()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// all done</span></span><br><span class="line">	mp.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">		throw(<span class="string">&quot;gc done but gcphase != _GCoff&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新下一次触发gc需要的heap大小(gc_trigger)</span></span><br><span class="line">	<span class="comment">// Update GC trigger and pacing for the next cycle.</span></span><br><span class="line">	gcSetTriggerRatio(nextTriggerRatio)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新用时记录</span></span><br><span class="line">	<span class="comment">// Update timing memstats</span></span><br><span class="line">	now := nanotime()</span><br><span class="line">	sec, nsec, _ := time_now()</span><br><span class="line">	unixNow := sec*<span class="number">1e9</span> + <span class="type">int64</span>(nsec)</span><br><span class="line">	work.pauseNS += now - work.pauseStart</span><br><span class="line">	work.tEnd = now</span><br><span class="line">	atomic.Store64(&amp;memstats.last_gc_unix, <span class="type">uint64</span>(unixNow)) <span class="comment">// must be Unix time to make sense to user</span></span><br><span class="line">	atomic.Store64(&amp;memstats.last_gc_nanotime, <span class="type">uint64</span>(now)) <span class="comment">// monotonic time for us</span></span><br><span class="line">	memstats.pause_ns[memstats.numgc%<span class="type">uint32</span>(<span class="built_in">len</span>(memstats.pause_ns))] = <span class="type">uint64</span>(work.pauseNS)</span><br><span class="line">	memstats.pause_end[memstats.numgc%<span class="type">uint32</span>(<span class="built_in">len</span>(memstats.pause_end))] = <span class="type">uint64</span>(unixNow)</span><br><span class="line">	memstats.pause_total_ns += <span class="type">uint64</span>(work.pauseNS)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新所用cpu记录</span></span><br><span class="line">	<span class="comment">// Update work.totaltime.</span></span><br><span class="line">	sweepTermCpu := <span class="type">int64</span>(work.stwprocs) * (work.tMark - work.tSweepTerm)</span><br><span class="line">	<span class="comment">// We report idle marking time below, but omit it from the</span></span><br><span class="line">	<span class="comment">// overall utilization here since it&#x27;s &quot;free&quot;.</span></span><br><span class="line">	markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime</span><br><span class="line">	markTermCpu := <span class="type">int64</span>(work.stwprocs) * (work.tEnd - work.tMarkTerm)</span><br><span class="line">	cycleCpu := sweepTermCpu + markCpu + markTermCpu</span><br><span class="line">	work.totaltime += cycleCpu</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute overall GC CPU utilization.</span></span><br><span class="line">	totalCpu := sched.totaltime + (now-sched.procresizetime)*<span class="type">int64</span>(gomaxprocs)</span><br><span class="line">	memstats.gc_cpu_fraction = <span class="type">float64</span>(work.totaltime) / <span class="type">float64</span>(totalCpu)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置清扫状态</span></span><br><span class="line">	<span class="comment">// Reset sweep state.</span></span><br><span class="line">	sweep.nbgsweep = <span class="number">0</span></span><br><span class="line">	sweep.npausesweep = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计强制开始GC的次数</span></span><br><span class="line">	<span class="keyword">if</span> work.userForced &#123;</span><br><span class="line">		memstats.numforcedgc++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计执行GC的次数然后唤醒等待清扫的G</span></span><br><span class="line">	<span class="comment">// Bump GC cycle count and wake goroutines waiting on sweep.</span></span><br><span class="line">	lock(&amp;work.sweepWaiters.lock)</span><br><span class="line">	memstats.numgc++</span><br><span class="line">	injectglist(work.sweepWaiters.head.ptr())</span><br><span class="line">	work.sweepWaiters.head = <span class="number">0</span></span><br><span class="line">	unlock(&amp;work.sweepWaiters.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 性能统计用</span></span><br><span class="line">	<span class="comment">// Finish the current heap profiling cycle and start a new</span></span><br><span class="line">	<span class="comment">// heap profiling cycle. We do this before starting the world</span></span><br><span class="line">	<span class="comment">// so events don&#x27;t leak into the wrong cycle.</span></span><br><span class="line">	mProf_NextCycle()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新启动世界</span></span><br><span class="line">	systemstack(startTheWorldWithSema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line">	<span class="comment">// 世界已重新启动...</span></span><br><span class="line">	<span class="comment">// !!!!!!!!!!!!!!!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 性能统计用</span></span><br><span class="line">	<span class="comment">// Flush the heap profile so we can start a new cycle next GC.</span></span><br><span class="line">	<span class="comment">// This is relatively expensive, so we don&#x27;t do it with the</span></span><br><span class="line">	<span class="comment">// world stopped.</span></span><br><span class="line">	mProf_Flush()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动标记队列使用的缓冲区到自由列表, 使得它们可以被回收</span></span><br><span class="line">	<span class="comment">// Prepare workbufs for freeing by the sweeper. We do this</span></span><br><span class="line">	<span class="comment">// asynchronously because it can take non-trivial time.</span></span><br><span class="line">	prepareFreeWorkbufs()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放未使用的栈</span></span><br><span class="line">	<span class="comment">// Free stack spans. This must be done between GC cycles.</span></span><br><span class="line">	systemstack(freeStackSpans)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 除错用</span></span><br><span class="line">	<span class="comment">// Print gctrace before dropping worldsema. As soon as we drop</span></span><br><span class="line">	<span class="comment">// worldsema another cycle could start and smash the stats</span></span><br><span class="line">	<span class="comment">// we&#x27;re trying to print.</span></span><br><span class="line">	<span class="keyword">if</span> debug.gctrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">		util := <span class="type">int</span>(memstats.gc_cpu_fraction * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> sbuf [<span class="number">24</span>]<span class="type">byte</span></span><br><span class="line">		printlock()</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;gc &quot;</span>, memstats.numgc,</span><br><span class="line">			<span class="string">&quot; @&quot;</span>, <span class="type">string</span>(itoaDiv(sbuf[:], <span class="type">uint64</span>(work.tSweepTerm-runtimeInitTime)/<span class="number">1e6</span>, <span class="number">3</span>)), <span class="string">&quot;s &quot;</span>,</span><br><span class="line">			util, <span class="string">&quot;%: &quot;</span>)</span><br><span class="line">		prev := work.tSweepTerm</span><br><span class="line">		<span class="keyword">for</span> i, ns := <span class="keyword">range</span> []<span class="type">int64</span>&#123;work.tMark, work.tMarkTerm, work.tEnd&#125; &#123;</span><br><span class="line">			<span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">print</span>(<span class="type">string</span>(fmtNSAsMS(sbuf[:], <span class="type">uint64</span>(ns-prev))))</span><br><span class="line">			prev = ns</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot; ms clock, &quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> i, ns := <span class="keyword">range</span> []<span class="type">int64</span>&#123;sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu&#125; &#123;</span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">2</span> || i == <span class="number">3</span> &#123;</span><br><span class="line">				<span class="comment">// Separate mark time components with /.</span></span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">print</span>(<span class="type">string</span>(fmtNSAsMS(sbuf[:], <span class="type">uint64</span>(ns))))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot; ms cpu, &quot;</span>,</span><br><span class="line">			work.heap0&gt;&gt;<span class="number">20</span>, <span class="string">&quot;-&gt;&quot;</span>, work.heap1&gt;&gt;<span class="number">20</span>, <span class="string">&quot;-&gt;&quot;</span>, work.heap2&gt;&gt;<span class="number">20</span>, <span class="string">&quot; MB, &quot;</span>,</span><br><span class="line">			work.heapGoal&gt;&gt;<span class="number">20</span>, <span class="string">&quot; MB goal, &quot;</span>,</span><br><span class="line">			work.maxprocs, <span class="string">&quot; P&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> work.userForced &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot; (forced)&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		printunlock()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	semrelease(&amp;worldsema)</span><br><span class="line">	<span class="comment">// Careful: another GC cycle may start now.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新允许当前的G被抢占</span></span><br><span class="line">	releasem(mp)</span><br><span class="line">	mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是并行GC, 让当前M继续运行(会回到gcBgMarkWorker然后休眠)</span></span><br><span class="line">	<span class="comment">// 如果不是并行GC, 则让当前M开始调度</span></span><br><span class="line">	<span class="comment">// now that gc is done, kick off finalizer thread if needed</span></span><br><span class="line">	<span class="keyword">if</span> !concurrentSweep &#123;</span><br><span class="line">		<span class="comment">// give the queued finalizers, if any, a chance to run</span></span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L1987">gcSweep</a>函数会唤醒后台清扫任务:<br>后台清扫任务会在程序启动时调用的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L214">gcenable</a>函数中启动.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcSweep</span><span class="params">(mode gcMode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">		throw(<span class="string">&quot;gcSweep being done but phase is not GCoff&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加sweepgen, 这样sweepSpans中两个队列角色会交换, 所有span都会变为&quot;待清扫&quot;的span</span></span><br><span class="line">	lock(&amp;mheap_.lock)</span><br><span class="line">	mheap_.sweepgen += <span class="number">2</span></span><br><span class="line">	mheap_.sweepdone = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> mheap_.sweepSpans[mheap_.sweepgen/<span class="number">2</span>%<span class="number">2</span>].index != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// We should have drained this list during the last</span></span><br><span class="line">		<span class="comment">// sweep phase. We certainly need to start this phase</span></span><br><span class="line">		<span class="comment">// with an empty swept list.</span></span><br><span class="line">		throw(<span class="string">&quot;non-empty swept list&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mheap_.pagesSwept = <span class="number">0</span></span><br><span class="line">	unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果非并行GC则在这里完成所有工作(STW中)</span></span><br><span class="line">	<span class="keyword">if</span> !_ConcurrentSweep || mode == gcForceBlockMode &#123;</span><br><span class="line">		<span class="comment">// Special case synchronous sweep.</span></span><br><span class="line">		<span class="comment">// Record that no proportional sweeping has to happen.</span></span><br><span class="line">		lock(&amp;mheap_.lock)</span><br><span class="line">		mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">		unlock(&amp;mheap_.lock)</span><br><span class="line">		<span class="comment">// Sweep all spans eagerly.</span></span><br><span class="line">		<span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">			sweep.npausesweep++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Free workbufs eagerly.</span></span><br><span class="line">		prepareFreeWorkbufs()</span><br><span class="line">		<span class="keyword">for</span> freeSomeWbufs(<span class="literal">false</span>) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// All &quot;free&quot; events for this mark/sweep cycle have</span></span><br><span class="line">		<span class="comment">// now happened, so we can make this profile cycle</span></span><br><span class="line">		<span class="comment">// available immediately.</span></span><br><span class="line">		mProf_NextCycle()</span><br><span class="line">		mProf_Flush()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 唤醒后台清扫任务</span></span><br><span class="line">	<span class="comment">// Background sweep.</span></span><br><span class="line">	lock(&amp;sweep.lock)</span><br><span class="line">	<span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">		sweep.parked = <span class="literal">false</span></span><br><span class="line">		ready(sweep.g, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sweep.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台清扫任务的函数是<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L46">bgsweep</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgsweep</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sweep.g = getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待唤醒</span></span><br><span class="line">	lock(&amp;sweep.lock)</span><br><span class="line">	sweep.parked = <span class="literal">true</span></span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	goparkunlock(&amp;sweep.lock, <span class="string">&quot;GC sweep wait&quot;</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环清扫</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 清扫一个span, 然后进入调度(一次只做少量工作)</span></span><br><span class="line">		<span class="keyword">for</span> gosweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">			sweep.nbgsweep++</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 释放一些未使用的标记队列缓冲区到heap</span></span><br><span class="line">		<span class="keyword">for</span> freeSomeWbufs(<span class="literal">true</span>) &#123;</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果清扫未完成则继续循环</span></span><br><span class="line">		lock(&amp;sweep.lock)</span><br><span class="line">		<span class="keyword">if</span> !gosweepdone() &#123;</span><br><span class="line">			<span class="comment">// This can happen if a GC runs between</span></span><br><span class="line">			<span class="comment">// gosweepone returning ^0 above</span></span><br><span class="line">			<span class="comment">// and the lock being acquired.</span></span><br><span class="line">			unlock(&amp;sweep.lock)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则让后台清扫任务进入休眠, 当前M继续调度</span></span><br><span class="line">		sweep.parked = <span class="literal">true</span></span><br><span class="line">		goparkunlock(&amp;sweep.lock, <span class="string">&quot;GC sweep wait&quot;</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L134">gosweepone</a>函数会从sweepSpans中取出单个span清扫:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gosweepone</span><span class="params">()</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret <span class="type">uintptr</span></span><br><span class="line">	<span class="comment">// 切换到g0运行</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ret = sweepone()</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L78">sweepone</a>函数如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sweeps one span</span></span><br><span class="line"><span class="comment">// returns number of pages returned to heap, or ^uintptr(0) if there is nothing to sweep</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	sweepRatio := mheap_.sweepPagesPerByte <span class="comment">// For debugging</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 禁止G被抢占</span></span><br><span class="line">	<span class="comment">// increment locks to ensure that the goroutine is not preempted</span></span><br><span class="line">	<span class="comment">// in the middle of sweep thus leaving the span in an inconsistent state for next GC</span></span><br><span class="line">	_g_.m.locks++</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检查是否已完成清扫</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;mheap_.sweepdone) != <span class="number">0</span> &#123;</span><br><span class="line">		_g_.m.locks--</span><br><span class="line">		<span class="keyword">return</span> ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新同时执行sweep的任务数量</span></span><br><span class="line">	atomic.Xadd(&amp;mheap_.sweepers, +<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	npages := ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">	sg := mheap_.sweepgen</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 从sweepSpans中取出一个span</span></span><br><span class="line">		s := mheap_.sweepSpans[<span class="number">1</span>-sg/<span class="number">2</span>%<span class="number">2</span>].pop()</span><br><span class="line">		<span class="comment">// 全部清扫完毕时跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			atomic.Store(&amp;mheap_.sweepdone, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他M已经在清扫这个span时跳过</span></span><br><span class="line">		<span class="keyword">if</span> s.state != mSpanInUse &#123;</span><br><span class="line">			<span class="comment">// This can happen if direct sweeping already</span></span><br><span class="line">			<span class="comment">// swept this span, but in that case the sweep</span></span><br><span class="line">			<span class="comment">// generation should always be up-to-date.</span></span><br><span class="line">			<span class="keyword">if</span> s.sweepgen != sg &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">&quot;runtime: bad span s.state=&quot;</span>, s.state, <span class="string">&quot; s.sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; sweepgen=&quot;</span>, sg, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">				throw(<span class="string">&quot;non in-use span in unswept list&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 原子增加span的sweepgen, 失败表示其他M已经开始清扫这个span, 跳过</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen != sg<span class="number">-2</span> || !atomic.Cas(&amp;s.sweepgen, sg<span class="number">-2</span>, sg<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清扫这个span, 然后跳出循环</span></span><br><span class="line">		npages = s.npages</span><br><span class="line">		<span class="keyword">if</span> !s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="comment">// Span is still in-use, so this returned no</span></span><br><span class="line">			<span class="comment">// pages to the heap and the span needs to</span></span><br><span class="line">			<span class="comment">// move to the swept in-use list.</span></span><br><span class="line">			npages = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新同时执行sweep的任务数量</span></span><br><span class="line">	<span class="comment">// Decrement the number of active sweepers and if this is the</span></span><br><span class="line">	<span class="comment">// last one print trace information.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Xadd(&amp;mheap_.sweepers, <span class="number">-1</span>) == <span class="number">0</span> &amp;&amp; atomic.Load(&amp;mheap_.sweepdone) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> debug.gcpacertrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;pacer: sweep done at heap size &quot;</span>, memstats.heap_live&gt;&gt;<span class="number">20</span>, <span class="string">&quot;MB; allocated &quot;</span>, (memstats.heap_live-mheap_.sweepHeapLiveBasis)&gt;&gt;<span class="number">20</span>, <span class="string">&quot;MB during sweep; swept &quot;</span>, mheap_.pagesSwept, <span class="string">&quot; pages at &quot;</span>, sweepRatio, <span class="string">&quot; pages/byte\n&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 允许G被抢占</span></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	<span class="comment">// 返回清扫的页数</span></span><br><span class="line">	<span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>span的<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcsweep.go#L179">sweep</a>函数用于清扫单个span:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sweep frees or collects finalizers for blocks not marked in the mark phase.</span></span><br><span class="line"><span class="comment">// It clears the mark bits in preparation for the next GC round.</span></span><br><span class="line"><span class="comment">// Returns true if the span was returned to heap.</span></span><br><span class="line"><span class="comment">// If preserve=true, don&#x27;t return it to heap nor relink in MCentral lists;</span></span><br><span class="line"><span class="comment">// caller takes care of it.</span></span><br><span class="line"><span class="comment">//TODO go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span></span> sweep(preserve <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// It&#x27;s critical that we enter this function with preemption disabled,</span></span><br><span class="line">	<span class="comment">// GC must not start while we are in the middle of this function.</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.m.mallocing == <span class="number">0</span> &amp;&amp; _g_ != _g_.m.g0 &#123;</span><br><span class="line">		throw(<span class="string">&quot;MSpan_Sweep: m is not locked&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	sweepgen := mheap_.sweepgen</span><br><span class="line">	<span class="keyword">if</span> s.state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;MSpan_Sweep: state=&quot;</span>, s.state, <span class="string">&quot; sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; mheap.sweepgen=&quot;</span>, sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;MSpan_Sweep: bad span state&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepSpan(s.npages * _PageSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计已清理的页数</span></span><br><span class="line">	atomic.Xadd64(&amp;mheap_.pagesSwept, <span class="type">int64</span>(s.npages))</span><br><span class="line"></span><br><span class="line">	spc := s.spanclass</span><br><span class="line">	size := s.elemsize</span><br><span class="line">	res := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	c := _g_.m.mcache</span><br><span class="line">	freeToHeap := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The allocBits indicate which unmarked objects don&#x27;t need to be</span></span><br><span class="line">	<span class="comment">// processed since they were free at the end of the last GC cycle</span></span><br><span class="line">	<span class="comment">// and were not allocated since then.</span></span><br><span class="line">	<span class="comment">// If the allocBits index is &gt;= s.freeindex and the bit</span></span><br><span class="line">	<span class="comment">// is not marked then the object remains unallocated</span></span><br><span class="line">	<span class="comment">// since the last GC.</span></span><br><span class="line">	<span class="comment">// This situation is analogous to being on a freelist.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断在special中的析构器, 如果对应的对象已经不再存活则标记对象存活防止回收, 然后把析构器移到运行队列</span></span><br><span class="line">	<span class="comment">// Unlink &amp; free special records for any objects we&#x27;re about to free.</span></span><br><span class="line">	<span class="comment">// Two complications here:</span></span><br><span class="line">	<span class="comment">// 1. An object can have both finalizer and profile special records.</span></span><br><span class="line">	<span class="comment">//    In such case we need to queue finalizer for execution,</span></span><br><span class="line">	<span class="comment">//    mark the object as live and preserve the profile special.</span></span><br><span class="line">	<span class="comment">// 2. A tiny object can have several finalizers setup for different offsets.</span></span><br><span class="line">	<span class="comment">//    If such object is not marked, we need to queue all finalizers at once.</span></span><br><span class="line">	<span class="comment">// Both 1 and 2 are possible at the same time.</span></span><br><span class="line">	specialp := &amp;s.specials</span><br><span class="line">	special := *specialp</span><br><span class="line">	<span class="keyword">for</span> special != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// A finalizer can be set for an inner byte of an object, find object beginning.</span></span><br><span class="line">		objIndex := <span class="type">uintptr</span>(special.offset) / size</span><br><span class="line">		p := s.base() + objIndex*size</span><br><span class="line">		mbits := s.markBitsForIndex(objIndex)</span><br><span class="line">		<span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line">			<span class="comment">// This object is not marked and has at least one special record.</span></span><br><span class="line">			<span class="comment">// Pass 1: see if it has at least one finalizer.</span></span><br><span class="line">			hasFin := <span class="literal">false</span></span><br><span class="line">			endOffset := p - s.base() + size</span><br><span class="line">			<span class="keyword">for</span> tmp := special; tmp != <span class="literal">nil</span> &amp;&amp; <span class="type">uintptr</span>(tmp.offset) &lt; endOffset; tmp = tmp.next &#123;</span><br><span class="line">				<span class="keyword">if</span> tmp.kind == _KindSpecialFinalizer &#123;</span><br><span class="line">					<span class="comment">// Stop freeing of object if it has a finalizer.</span></span><br><span class="line">					mbits.setMarkedNonAtomic()</span><br><span class="line">					hasFin = <span class="literal">true</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Pass 2: queue all finalizers _or_ handle profile record.</span></span><br><span class="line">			<span class="keyword">for</span> special != <span class="literal">nil</span> &amp;&amp; <span class="type">uintptr</span>(special.offset) &lt; endOffset &#123;</span><br><span class="line">				<span class="comment">// Find the exact byte for which the special was setup</span></span><br><span class="line">				<span class="comment">// (as opposed to object beginning).</span></span><br><span class="line">				p := s.base() + <span class="type">uintptr</span>(special.offset)</span><br><span class="line">				<span class="keyword">if</span> special.kind == _KindSpecialFinalizer || !hasFin &#123;</span><br><span class="line">					<span class="comment">// Splice out special record.</span></span><br><span class="line">					y := special</span><br><span class="line">					special = special.next</span><br><span class="line">					*specialp = special</span><br><span class="line">					freespecial(y, unsafe.Pointer(p), size)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// This is profile record, but the object has finalizers (so kept alive).</span></span><br><span class="line">					<span class="comment">// Keep special record.</span></span><br><span class="line">					specialp = &amp;special.next</span><br><span class="line">					special = *specialp</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// object is still live: keep special record</span></span><br><span class="line">			specialp = &amp;special.next</span><br><span class="line">			special = *specialp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 除错用</span></span><br><span class="line">	<span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> || raceenabled || msanenabled &#123;</span><br><span class="line">		<span class="comment">// Find all newly freed objects. This doesn&#x27;t have to</span></span><br><span class="line">		<span class="comment">// efficient; allocfreetrace has massive overhead.</span></span><br><span class="line">		mbits := s.markBitsForBase()</span><br><span class="line">		abits := s.allocBitsForIndex(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; s.nelems; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> !mbits.isMarked() &amp;&amp; (abits.index &lt; s.freeindex || abits.isMarked()) &#123;</span><br><span class="line">				x := s.base() + i*s.elemsize</span><br><span class="line">				<span class="keyword">if</span> debug.allocfreetrace != <span class="number">0</span> &#123;</span><br><span class="line">					tracefree(unsafe.Pointer(x), size)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">					racefree(unsafe.Pointer(x), size)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">					msanfree(unsafe.Pointer(x), size)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mbits.advance()</span><br><span class="line">			abits.advance()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算释放的对象数量</span></span><br><span class="line">	<span class="comment">// Count the number of free objects in this span.</span></span><br><span class="line">	nalloc := <span class="type">uint16</span>(s.countAlloc())</span><br><span class="line">	<span class="keyword">if</span> spc.sizeclass() == <span class="number">0</span> &amp;&amp; nalloc == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果span的类型是0(大对象)并且其中的对象已经不存活则释放到heap</span></span><br><span class="line">		s.needzero = <span class="number">1</span></span><br><span class="line">		freeToHeap = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	nfreed := s.allocCount - nalloc</span><br><span class="line">	<span class="keyword">if</span> nalloc &gt; s.allocCount &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: nelems=&quot;</span>, s.nelems, <span class="string">&quot; nalloc=&quot;</span>, nalloc, <span class="string">&quot; previous allocCount=&quot;</span>, s.allocCount, <span class="string">&quot; nfreed=&quot;</span>, nfreed, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;sweep increased allocation count&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新的allocCount</span></span><br><span class="line">	s.allocCount = nalloc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断span是否无未分配的对象</span></span><br><span class="line">	wasempty := s.nextFreeIndex() == s.nelems</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置freeindex, 下次分配从0开始搜索</span></span><br><span class="line">	s.freeindex = <span class="number">0</span> <span class="comment">// reset allocation index to start of span.</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		getg().m.p.ptr().traceReclaimed += <span class="type">uintptr</span>(nfreed) * s.elemsize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcmarkBits变为新的allocBits</span></span><br><span class="line">	<span class="comment">// 然后重新分配一块全部为0的gcmarkBits</span></span><br><span class="line">	<span class="comment">// 下次分配对象时可以根据allocBits得知哪些元素是未分配的</span></span><br><span class="line">	<span class="comment">// gcmarkBits becomes the allocBits.</span></span><br><span class="line">	<span class="comment">// get a fresh cleared gcmarkBits in preparation for next GC</span></span><br><span class="line">	s.allocBits = s.gcmarkBits</span><br><span class="line">	s.gcmarkBits = newMarkBits(s.nelems)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新freeindex开始的allocCache</span></span><br><span class="line">	<span class="comment">// Initialize alloc bits cache.</span></span><br><span class="line">	s.refillAllocCache(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果span中已经无存活的对象则更新sweepgen到最新</span></span><br><span class="line">	<span class="comment">// 下面会把span加到mcentral或者mheap</span></span><br><span class="line">	<span class="comment">// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,</span></span><br><span class="line">	<span class="comment">// because of the potential for a concurrent free/SetFinalizer.</span></span><br><span class="line">	<span class="comment">// But we need to set it before we make the span available for allocation</span></span><br><span class="line">	<span class="comment">// (return it to heap or mcentral), because allocation code assumes that a</span></span><br><span class="line">	<span class="comment">// span is already swept if available for allocation.</span></span><br><span class="line">	<span class="keyword">if</span> freeToHeap || nfreed == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The span must be in our exclusive ownership until we update sweepgen,</span></span><br><span class="line">		<span class="comment">// check for potential races.</span></span><br><span class="line">		<span class="keyword">if</span> s.state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;MSpan_Sweep: state=&quot;</span>, s.state, <span class="string">&quot; sweepgen=&quot;</span>, s.sweepgen, <span class="string">&quot; mheap.sweepgen=&quot;</span>, sweepgen, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			throw(<span class="string">&quot;MSpan_Sweep: bad span state after sweep&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Serialization point.</span></span><br><span class="line">		<span class="comment">// At this point the mark bits are cleared and allocation ready</span></span><br><span class="line">		<span class="comment">// to go so release the span.</span></span><br><span class="line">		atomic.Store(&amp;s.sweepgen, sweepgen)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nfreed &gt; <span class="number">0</span> &amp;&amp; spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 把span加到mcentral, res等于是否添加成功</span></span><br><span class="line">		c.local_nsmallfree[spc.sizeclass()] += <span class="type">uintptr</span>(nfreed)</span><br><span class="line">		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)</span><br><span class="line">		<span class="comment">// freeSpan会更新sweepgen</span></span><br><span class="line">		<span class="comment">// MCentral_FreeSpan updates sweepgen</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> freeToHeap &#123;</span><br><span class="line">		<span class="comment">// 把span释放到mheap</span></span><br><span class="line">		<span class="comment">// Free large span to heap</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// NOTE(rsc,dvyukov): The original implementation of efence</span></span><br><span class="line">		<span class="comment">// in CL 22060046 used SysFree instead of SysFault, so that</span></span><br><span class="line">		<span class="comment">// the operating system would eventually give the memory</span></span><br><span class="line">		<span class="comment">// back to us again, so that an efence program could run</span></span><br><span class="line">		<span class="comment">// longer without running out of memory. Unfortunately,</span></span><br><span class="line">		<span class="comment">// calling SysFree here without any kind of adjustment of the</span></span><br><span class="line">		<span class="comment">// heap data structures means that when the memory does</span></span><br><span class="line">		<span class="comment">// come back to us, we have the wrong metadata for it, either in</span></span><br><span class="line">		<span class="comment">// the MSpan structures or in the garbage collection bitmap.</span></span><br><span class="line">		<span class="comment">// Using SysFault here means that the program will run out of</span></span><br><span class="line">		<span class="comment">// memory fairly quickly in efence mode, but at least it won&#x27;t</span></span><br><span class="line">		<span class="comment">// have mysterious crashes due to confused memory reuse.</span></span><br><span class="line">		<span class="comment">// It should be possible to switch back to SysFree if we also</span></span><br><span class="line">		<span class="comment">// implement and then call some kind of MHeap_DeleteSpan.</span></span><br><span class="line">		<span class="keyword">if</span> debug.efence &gt; <span class="number">0</span> &#123;</span><br><span class="line">			s.limit = <span class="number">0</span> <span class="comment">// prevent mlookup from finding this span</span></span><br><span class="line">			sysFault(unsafe.Pointer(s.base()), size)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mheap_.freeSpan(s, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		c.local_nlargefree++</span><br><span class="line">		c.local_largefree += size</span><br><span class="line">		res = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果span未加到mcentral或者未释放到mheap, 则表示span仍在使用</span></span><br><span class="line">	<span class="keyword">if</span> !res &#123;</span><br><span class="line">		<span class="comment">// 把仍在使用的span加到sweepSpans的&quot;已清扫&quot;队列中</span></span><br><span class="line">		<span class="comment">// The span has been swept and is still in-use, so put</span></span><br><span class="line">		<span class="comment">// it on the swept in-use list.</span></span><br><span class="line">		mheap_.sweepSpans[sweepgen/<span class="number">2</span>%<span class="number">2</span>].push(s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从bgsweep和前面的分配器可以看出扫描阶段的工作是十分懒惰(lazy)的,<br>实际可能会出现前一阶段的扫描还未完成, 就需要开始新一轮的GC的情况,<br>所以每一轮GC开始之前都需要完成前一轮GC的扫描工作(Sweep Termination阶段).</p>
<p>GC的整个流程都分析完毕了, 最后贴上写屏障函数<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L202">writebarrierptr</a>的实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Really dst *unsafe.Pointer, src unsafe.Pointer,</span></span><br><span class="line"><span class="comment">// but if we do that, Go inserts a write barrier on *dst = src.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writebarrierptr</span><span class="params">(dst *<span class="type">uintptr</span>, src <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> writeBarrier.cgo &#123;</span><br><span class="line">		cgoCheckWriteBarrier(dst, src)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !writeBarrier.needed &#123;</span><br><span class="line">		*dst = src</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> src != <span class="number">0</span> &amp;&amp; src &lt; minPhysPageSize &#123;</span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: writebarrierptr *&quot;</span>, dst, <span class="string">&quot; = &quot;</span>, hex(src), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			throw(<span class="string">&quot;bad pointer in write barrier&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 标记指针</span></span><br><span class="line">	writebarrierptr_prewrite1(dst, src)</span><br><span class="line">	<span class="comment">// 设置指针到目标</span></span><br><span class="line">	*dst = src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L182">writebarrierptr_prewrite1</a>函数如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writebarrierptr_prewrite1 invokes a write barrier for *dst = src</span></span><br><span class="line"><span class="comment">// prior to the write happening.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barrier calls must not happen during critical GC and scheduler</span></span><br><span class="line"><span class="comment">// related operations. In particular there are times when the GC assumes</span></span><br><span class="line"><span class="comment">// that the world is stopped but scheduler related code is still being</span></span><br><span class="line"><span class="comment">// executed, dealing with syscalls, dealing with putting gs on runnable</span></span><br><span class="line"><span class="comment">// queues and so forth. This code cannot execute write barriers because</span></span><br><span class="line"><span class="comment">// the GC might drop them on the floor. Stopping the world involves removing</span></span><br><span class="line"><span class="comment">// the p associated with an m. We use the fact that m.p == nil to indicate</span></span><br><span class="line"><span class="comment">// that we are in one these critical section and throw if the write is of</span></span><br><span class="line"><span class="comment">// a pointer to a heap object.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writebarrierptr_prewrite1</span><span class="params">(dst *<span class="type">uintptr</span>, src <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	<span class="keyword">if</span> mp.inwb || mp.dying &gt; <span class="number">0</span> &#123;</span><br><span class="line">		releasem(mp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> mp.p == <span class="number">0</span> &amp;&amp; memstats.enablegc &amp;&amp; !mp.inwb &amp;&amp; inheap(src) &#123;</span><br><span class="line">			throw(<span class="string">&quot;writebarrierptr_prewrite1 called with mp.p == nil&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mp.inwb = <span class="literal">true</span></span><br><span class="line">		gcmarkwb_m(dst, src)</span><br><span class="line">	&#125;)</span><br><span class="line">	mp.inwb = <span class="literal">false</span></span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mbarrier.go#L142">gcmarkwb_m</a>函数如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcmarkwb_m</span><span class="params">(slot *<span class="type">uintptr</span>, ptr <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> writeBarrier.needed &#123;</span><br><span class="line">		<span class="comment">// Note: This turns bad pointer writes into bad</span></span><br><span class="line">		<span class="comment">// pointer reads, which could be confusing. We avoid</span></span><br><span class="line">		<span class="comment">// reading from obviously bad pointers, which should</span></span><br><span class="line">		<span class="comment">// take care of the vast majority of these. We could</span></span><br><span class="line">		<span class="comment">// patch this up in the signal handler, or use XCHG to</span></span><br><span class="line">		<span class="comment">// combine the read and the write. Checking inheap is</span></span><br><span class="line">		<span class="comment">// insufficient since we need to track changes to</span></span><br><span class="line">		<span class="comment">// roots outside the heap.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Note: profbuf.go omits a barrier during signal handler</span></span><br><span class="line">		<span class="comment">// profile logging; that&#x27;s safe only because this deletion barrier exists.</span></span><br><span class="line">		<span class="comment">// If we remove the deletion barrier, we&#x27;ll have to work out</span></span><br><span class="line">		<span class="comment">// a new way to handle the profile logging.</span></span><br><span class="line">		<span class="keyword">if</span> slot1 := <span class="type">uintptr</span>(unsafe.Pointer(slot)); slot1 &gt;= minPhysPageSize &#123;</span><br><span class="line">			<span class="keyword">if</span> optr := *slot; optr != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 标记旧指针</span></span><br><span class="line">				shade(optr)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> Make this conditional on the caller&#x27;s stack color.</span></span><br><span class="line">		<span class="keyword">if</span> ptr != <span class="number">0</span> &amp;&amp; inheap(ptr) &#123;</span><br><span class="line">			<span class="comment">// 标记新指针</span></span><br><span class="line">			shade(ptr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L1200">shade</a>函数如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shade the object if it isn&#x27;t already.</span></span><br><span class="line"><span class="comment">// The object is not nil and known to be in the heap.</span></span><br><span class="line"><span class="comment">// Preemption must be disabled.</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shade</span><span class="params">(b <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> obj, hbits, span, objIndex := heapBitsForObject(b, <span class="number">0</span>, <span class="number">0</span>); obj != <span class="number">0</span> &#123;</span><br><span class="line">		gcw := &amp;getg().m.p.ptr().gcw</span><br><span class="line">		<span class="comment">// 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)</span></span><br><span class="line">		greyobject(obj, <span class="number">0</span>, <span class="number">0</span>, hbits, span, gcw, objIndex)</span><br><span class="line">		<span class="comment">// 如果标记了禁止本地标记队列则flush到全局标记队列</span></span><br><span class="line">		<span class="keyword">if</span> gcphase == _GCmarktermination || gcBlackenPromptly &#123;</span><br><span class="line">			<span class="comment">// Ps aren&#x27;t allowed to cache work during mark</span></span><br><span class="line">			<span class="comment">// termination.</span></span><br><span class="line">			gcw.dispose()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://github.com/golang/go">https://github.com/golang/go</a><br><a target="_blank" rel="noopener" href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice">https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice</a><br><a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a><br><a target="_blank" rel="noopener" href="https://golang.org/s/go15gcpacing">https://golang.org/s/go15gcpacing</a><br><a target="_blank" rel="noopener" href="https://golang.org/ref/mem">https://golang.org/ref/mem</a><br><a target="_blank" rel="noopener" href="https://talks.golang.org/2015/go-gc.pdf">https://talks.golang.org/2015/go-gc.pdf</a><br><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.x4kziklnb8fr">https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.x4kziklnb8fr</a><br><a target="_blank" rel="noopener" href="https://go-review.googlesource.com/c/go/+/21503">https://go-review.googlesource.com/c/go/+/21503</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/diegodu/p/5803202.html">http://www.cnblogs.com/diegodu/p/5803202.html</a><br><a target="_blank" rel="noopener" href="http://legendtkl.com/2017/04/28/golang-gc">http://legendtkl.com/2017/04/28/golang-gc</a><br><a target="_blank" rel="noopener" href="https://lengzzz.com/note/gc-in-golang">https://lengzzz.com/note/gc-in-golang</a></p>
<h1 id="Golang的GC和CoreCLR的GC对比"><a href="#Golang的GC和CoreCLR的GC对比" class="headerlink" title="Golang的GC和CoreCLR的GC对比"></a>Golang的GC和CoreCLR的GC对比</h1><p>因为我之前已经对CoreCLR的GC做过分析(看<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zkweb/p/6379080.html">这一篇</a>和<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zkweb/p/6625049.html">这一篇</a>), 这里我可以简单的对比一下CoreCLR和GO的GC实现:</p>
<ul>
<li>CoreCLR的对象带有类型信息, GO的对象不带, 而是通过bitmap区域记录哪些地方包含指针</li>
<li>CoreCLR分配对象的速度明显更快, GO分配对象需要查找span和写入bitmap区域</li>
<li>CoreCLR的收集器需要做的工作比GO多很多<ul>
<li>CoreCLR不同大小的对象都会放在一个segment中, 只能线性扫描</li>
<li>CoreCLR判断对象引用要访问类型信息, 而go只需要访问bitmap</li>
<li>CoreCLR清扫时要一个个去标记为自由对象, 而go只需要切换allocBits</li>
</ul>
</li>
<li>CoreCLR的停顿时间比GO要长<ul>
<li>虽然CoreCLR支持并行GC, 但是没有GO彻底, GO连扫描根对象都不需要完全停顿</li>
</ul>
</li>
<li>CoreCLR支持分代GC<ul>
<li>虽然Full GC时CoreCLR的效率不如GO, 但是CoreCLR可以在大部分时候只扫描第0和第1代的对象</li>
<li>因为支持分代GC, 通常CoreCLR花在GC上的CPU时间会比GO要少</li>
</ul>
</li>
</ul>
<p>CoreCLR的分配器和收集器通常比GO要高效, 也就是说CoreCLR会有更高的吞吐量.<br>但CoreCLR的最大停顿时间不如GO短, 这是因为GO的GC整个设计都是为了减少停顿时间.</p>
<p>现在分布式计算和横向扩展越来越流行,<br>比起追求单机吞吐量, 追求低延迟然后让分布式解决吞吐量问题无疑是更明智的选择,<br>GO的设计目标使得它比其他语言都更适合编写网络服务程序.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
              <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
              <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag"># 垃圾回收</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/02/go%20map%E8%A7%A3%E6%9E%90/" rel="prev" title="go map解析">
      <i class="fa fa-chevron-left"></i> go map解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/11/%E5%89%8D%E7%AB%AF%E7%BB%9F%E8%AE%A1SDK/" rel="next" title="前端统计SDK">
      前端统计SDK <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.0.1.</span> <span class="nav-text">内存结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BB%8EHeap%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.0.2.</span> <span class="nav-text">什么时候从Heap分配对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-Bitmap"><span class="nav-number">1.0.3.</span> <span class="nav-text">GC Bitmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Span"><span class="nav-number">1.0.4.</span> <span class="nav-text">Span</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Span%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.0.5.</span> <span class="nav-text">Span的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Span%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.0.6.</span> <span class="nav-text">Span的位置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">分配对象的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">2.0.1.</span> <span class="nav-text">分配对象的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.0.2.</span> <span class="nav-text">数据类型的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.0.3.</span> <span class="nav-text">源代码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">回收对象的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">3.0.1.</span> <span class="nav-text">回收对象的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.0.2.</span> <span class="nav-text">GC的触发条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E7%9A%84%E5%AE%9A%E4%B9%89-%E9%BB%91-%E7%81%B0-%E7%99%BD"><span class="nav-number">3.0.3.</span> <span class="nav-text">三色的定义(黑, 灰, 白)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C-Write-Barrier"><span class="nav-number">3.0.4.</span> <span class="nav-text">写屏障(Write Barrier)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9GC-mutator-assist"><span class="nav-number">3.0.5.</span> <span class="nav-text">辅助GC(mutator assist)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.0.6.</span> <span class="nav-text">根对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E9%98%9F%E5%88%97"><span class="nav-number">3.0.7.</span> <span class="nav-text">标记队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="nav-number">3.0.8.</span> <span class="nav-text">源代码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">4.</span> <span class="nav-text">参考链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang%E7%9A%84GC%E5%92%8CCoreCLR%E7%9A%84GC%E5%AF%B9%E6%AF%94"><span class="nav-number">5.</span> <span class="nav-text">Golang的GC和CoreCLR的GC对比</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="layne"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">layne</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Laynegu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Laynegu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1686814964@qq.com" title="E-Mail → mailto:1686814964@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user-astronaut"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">layne</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
